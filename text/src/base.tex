\documentclass[a4paper, 14pt, titlepage]{extarticle}
  \usepackage{cmap}
  \usepackage[hidelinks,pdftex,unicode]{hyperref}
  \usepackage{mathtext} % для кириллицы в формулах
  \usepackage[T2A]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage[english,russian]{babel}
  \usepackage{indentfirst}
  \usepackage{cite}
  \usepackage{amsmath} % для \eqref
  \usepackage{amssymb} % для \leqslant
  \usepackage{amsthm} % для \pushQED
  \usepackage[usenames,dvipsnames]{xcolor}
  \usepackage[pdftex]{graphicx}
  \usepackage{subfig}
  \usepackage{numprint}
  \usepackage[left=30mm,right=15mm,top=20mm,bottom=20mm,bindingoffset=0cm]{geometry}
  \usepackage{datetime}
  \usepackage{setspace} % для иных отступов в tikz-картинках
  \usepackage{tikz}
    \usepackage{tikz-uml}
    \usetikzlibrary{positioning,fit,shapes,calc,backgrounds}
    % Цветовая тема:
    \colorlet{color1}{violet}         \colorlet{color1bg}{violet!15}
      \colorlet{color1a}{violet!70!Blue}\colorlet{color1abg}{violet!20}
    \colorlet{color2}{cyan!80!Blue}   \colorlet{color2bg}{cyan!15}
    \colorlet{color3}{Emerald}        \colorlet{color3bg}{green!15}
    \colorlet{color4}{Orange}         \colorlet{color4bg}{orange!20}
    \colorlet{color5}{OliveGreen}     \colorlet{color5bg}{green!15!yellow!15}
    \colorlet{color0}{Gray}           \colorlet{color0bg}{Gray!10}
    % Определяет стили theme1, theme1a, theme2...
    \newcommand{\deftheme}[1]{\tikzstyle{theme#1}  = [draw=color#1,  fill=color#1bg]}
    \deftheme{0}\deftheme{1}\deftheme{1a}\deftheme{2}\deftheme{3}\deftheme{4}\deftheme{5}
  \usepackage[babel,protrusion=true,expansion]{microtype}
  \usepackage{nameref}
  \usepackage[labelsep=endash]{caption} % тире в подписях рисунков, таблиц
  \usepackage{listings}
    \lstloadlanguages{C++}
    \lstset{
      language=C++,          % везде язык C++
      extendedchars=true,    % включаем не латиницу
      frame=tb,              % рамка сверху и снизу
      basicstyle=\small, % основной шрифт
      commentstyle=\itshape\color{black!50}, % шрифт комментариев
      gobble=6,              % по умолчанию удалять 6 пробелов в начале строки (отступы от \begin)
      texcl=true,            % комментарии - TeX, позволяет использовать русские буквы
      xleftmargin=1.5cm,       % дефолтные поля по 2см,
      xrightmargin=1.5cm,      % чтобы смотрелось как рисунок
      morekeywords={nullptr, override,
        signals, slots, emit}, % ключевые слова Qt MOC и C++11
      breaklines=true,       % включить авто переносы
      breakatwhitespace=false, % разрешить переносить не только по пробелу
      showstringspaces=false % не подчёркивать пробелы в строках
    }
    % для кода в строчку
    \newcommand{\inlinecode}[1]{\lstinline[basicstyle=\ttfamily]{#1}}
  \usepackage{totcount} % для посчёта полного числа рисунков итп
    % подсчёт рисунков:
    \regtotcounter{figure}
    % подсчёт источников:
    \newtotcounter{citnum}
    \let\oldbibitem\bibitem
    \renewcommand\bibitem{\stepcounter{citnum}\oldbibitem}
    % правильный подсчёт страниц (от введения до заключения, не считая содержание и список источников
    % USAGE: Поместить \firstPageHere перед первой страницей, а \lastPageHere на последней странице.
    %        После этого можно использовать \total{pagenum} в любом месте документа
    \newtotcounter{pagenum}
    \newcounter{firstpage}
    \newcommand\firstPageHere{\setcounter{firstpage}{\value{page}}}
    \newcommand\lastPageHere{\setcounter{pagenum}{\value{page} - \value{firstpage}}}
  \graphicspath{{../img/}{../../img/}}
  \frenchspacing

  \DeclareSymbolFont{T2Aletters}{T2A}{cmr}{m}{it} % кириллица в формулах курсивом

  \addto\captionsrussian{
    \renewcommand\contentsname{\centering Содержание}
    \renewcommand\figurename{Рисунок}
    \renewcommand\refname{Список использованных источников}
    % перекрываю \refname, чтобы список литературы сам добавлял себя в оглавление
    \let\oldrefname\refname
    \renewcommand\refname{\addcontentsline{toc}{section}{\oldrefname}\centering \oldrefname}
  }

  % Ненумерованный section, но добавленный в оглавление
  \newcommand\sectiontoc[1]{\section*{\centering #1}\addcontentsline{toc}{section}{#1}}

  \newcommand{\underscore}[1]{\hbox to#1{\hrulefill}}
  \newcommand{\todo}[1]{\textbf{\textcolor{red}{TODO: #1}}}
  \newcommand{\note}[1]{\textit{Примечание: #1}}
  \newcommand{\eng}[1]{\foreignlanguage{english}{#1}}

  % выделение термина в определении (и не только)
  \newcommand{\term}[1]{\emph{#1}}

  % обёртка с моими настройками поверх figure:
  % \begin{myfigure}{подпись}{fig:label} ... \end{myfigure}
  \newenvironment{myfigure}[2]%
    {\pushQED{\caption{#1} \label{#2}} % push caption & label
     \begin{figure}[!htb]\centering } %
    {  \popQED % pop caption & label
     \end{figure}}

  % вставка картинки: \figure[params]{подпись}{file}
  % создаёт label вида fig:file
  \newcommand{\includefigure}[3][]{
    \begin{myfigure}{#2}{fig:#3}
      \includegraphics[#1]{#3}
    \end{myfigure}
  }

  % вставка subfigure внутри myfigure:
  % \subfigure[params]{подпись}{file}
  \newcommand{\subfigure}[3][]{
    \subfloat[#2]{\label{fig:#3}\includegraphics[#1]{#3}}
  }

  \renewcommand{\le}{\leqslant} % <= с наклонной нижней перекладиной
  \renewcommand{\ge}{\geqslant} % >= с наклонной нижней перекладиной

  \linespread{1.3}

  % русские буквы для списков и частей рисунка
  \renewcommand{\theenumii}{(\asbuk{enumii})}
  \renewcommand{\labelenumii}{\asbuk{enumii})}
  \renewcommand{\thesubfigure}{\asbuk{subfigure}}

  % разделы с новой страницы
  \let\oldsection\section
  \renewcommand{\section}{\newpage\oldsection}

  % \paragraph с обычным отступом первой строки слева, без отступа сверху
  % (http://tex.stackexchange.com/a/4895/24732)
  \makeatletter
  \renewcommand{\paragraph}{%
    \@startsection{paragraph}{4}%
    {\parindent}{\z@}{-1em}% was: {\z@}{3.25ex \@plus 1ex \@minus .2ex}{-1em}
    {\normalfont\normalsize\bfseries}%
  }
  \makeatother

  \setcounter{tocdepth}{3} % глубина оглавления

  \hyphenation{англ} % убрать перенос в этом сокращении

  % алиас и настройки для numprint
  \newcommand{\num}[1]{\numprint{#1}}
  \npthousandsep{\,}
  \npthousandthpartsep{}
  \npdecimalsign{,}

  \newcommand{\checkdate}[3]{(дата обращения: \formatdate{#1}{#2}{#3})}

  \newcommand{\thetitle}{Создание универсальной информационной системы обработки экспериментальных данных}
  \newcommand{\theauthor}{Иван Новиков}

  \author{\theauthor, кафедра физики и информационных систем КубГУ}
  \title{\thetitle}

  \hypersetup{
    pdfinfo={
      Title = {\thetitle},
      Author = {\theauthor},
      Subject = {}
    }
  }

\begin{document}

%----------------------- титульный лист ------------------------

  \thispagestyle{empty}
  \begin {center}
  \small{МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ}\\
  Федеральное государственное бюджетное образовательное учреждение\\
  высшего профессионального образования\\
  «КУБАНСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»\\
  (ФГБОУ ВПО «КубГУ»)

  Физико-технический факультет

  \vspace {1cm}

  Кафедра физики и информационных систем

  \vspace {1cm}

  \hfill
  \begin{minipage}{7cm}
    \begin{flushleft}
      Допустить к защите в ГАК\\
      \hspace*{0mm}\hrulefill{} 2014г.\\
      Заведующий кафедрой\\
      профессор, д-р физ.-мат. наук\\
      Н.\,М.\,Богатов \hrulefill{}\\
      ~\hrule
      \footnotesize{\centering (подпись, дата)\par}
    \end{flushleft}
  \end{minipage}

  \vspace {1.5cm}

  \textbf{МАГИСТЕРСКАЯ ДИССЕРТАЦИЯ}

  \vspace {0.5cm}

  \textbf{ \large \scshape \thetitle }

  \vspace {1.5cm}

  \begin{flushleft}
    Работу выполнил \hrulefill{}  (Новиков Иван Александрович)\\
    Направление магистерской подготовки 011200.68 Физика

    Руководитель магистерской программы <<Информационные процессы и системы>>\\
    профессор, д-р физ.-мат. наук \hrulefill{} (В.\,А.\,Исаев)

    Научный руководитель\\
    доцент, канд. физ.-мат. наук \hrulefill{} (Л.\,Р.\,Григорьян)

    Нормоконтролер\\
    доцент, канд. физ.-мат. наук \hrulefill{} (Л.\,Р.\,Григорьян)
  \end{flushleft}

  \vfill

  Краснодар 2014
  \end {center}

%------------------------- реферат -------------------------
  \sectiontoc{Реферат}

  Магистерская диссертация: \total{pagenum} страниц,
  \total{figure} рисунков, \total{citnum} источников.

  Автоматизация эксперимента, измерительные информационные системы, программное обеспечение,
  обработка сигналов.

  Объектом исследования являются экспериментальные данные и сигналы, используемые для их кодирования
  и передачи. Предмет исследования~--- способы повышения эффективности регистрации таких сигналов и
  обработки экспериментальных данных, в частности, автоматизация эксперимента и программное
  обеспечение измерительных информационных систем.

  Целью работы является разработка универсальной информационной системы обработки экспериментальных
  данных~--- специализированного программного обеспечения для автоматизации процесса сбора и
  обработки данных в процессе измерения.

  В рамках данной работы проведён анализ предметной области, рассмотрены существующие решения и
  обоснована необходимость разработки собственного решения. В результате выполнения работы была
  создана информационная система обработки данных, которая была испытана в реальной измерительной
  системе.


%------------------------- содержание -------------------------

  \microtypesetup{protrusion=false} % отключить protrusion для содержания
    \clearpage
    \tableofcontents
  \microtypesetup{protrusion=true}

%------------------------- сокращения -------------------------

  \sectiontoc{Обозначения и сокращения}

  В настоящей работе были применены следующие сокращения:

  \begin{tabular}{r c p{12cm}} % TODO какая должна быть ширина?
    АЦП & --- & аналого-цифровой преобразователь \\
    БПФ & --- & быстрое преобразование Фурье \\
    ДПФ & --- & дискретное преобразование Фурье \\
    ИВК & --- & измерительно-вычислительный комплекс \\
    ИИС & --- & измерительная информационная система \\
    ОЗУ & --- & оперативное запоминающее устройство \\
    ПО  & --- & программное обеспечение \\
    ТЭЦ & --- & теплоэлектроцентраль \\
    ЦАП & --- & цифро-аналоговый преобразователь \\
    ЭВМ & --- & электронная вычислительная машина \\[\baselineskip]

    FFT & --- & \eng{Fast Fourier transform}, быстрое преобразование Фурье \\
    GPS & --- & \eng{Global Positioning System}, система глобального позиционирования \\
    HTML& --- & \eng{HyperText Markup Language}, язык гипертекстовой разметки \\
    MOC & --- & \eng{Meta Object Compiler}, метаобъектный компилятор \\
    MVC & --- & \eng{Model~-- View~-- Controller}, Модель~-- Представление~-- Контроллер \\
    NTP & --- & \eng{Network Time Protocol}, сетевой протокол времени \\
    OOAD& --- & \eng{Object-Oriented Analysis and Design}, объектно"=ориентированное проектирование \\
    PNG & --- & \eng{Portable Network Graphics} (формат изображений) \\
    PTP & --- & \eng{Precision Time Protocol}, протокол точного времени \\
    SCADA & --- & \eng{Supervisory Control And Data Acquisition}, диспетчерское управление и сбор данных \\
    VCS & --- & \eng{Version Control System}, система контроля версий \\
    % TODO дополнить список
  \end{tabular}

%-------------------------- введение --------------------------
  \firstPageHere
  \sectiontoc{Введение}\label{sec:intro}

  В процессе производственной и познавательной деятельности возникает множество практических и
  теоретических задач, для решения которых необходимо располагать количественной информацией о том
  или ином свойстве объекта. Основным способом получения такой информации является процесс измерения.
  Измерения лежат в основе экспериментальной науки, как фундаментальной, так и прикладной. При этом
  в последнее время, в~связи с широким распространением цифровых технологий, точные измерения можно
  встретить не только в научной лаборатории, но и на производстве и в быту.
  Поэтому задача повышения эффективности и достоверности процессов измерения и обработки информации
  является актуальной.

  Усложнение технологий, применяемых на производстве, и развитие научных методов создаёт
  необходимость измерения и контроля многих параметров, вплоть до сотен и тысяч, а также
  выполнения большого числа измерений в единицу времени. Это привело к появлению нового класса
  измерительной техники~--- \term{измерительных информационных систем} \cite{rannev-iis,rannev-meas-tech},
  выполняющих задачи сбора, обработки, передачи, хранения и отображения информации.
  Понятие измерительных информационных систем (ИИС) и предметная область их применения описаны в
  разделе~\ref{sec:iis}.

  По мере усложнения задач, выполняемых системами измерения, возрастает как сложность самих систем,
  так и требования к их скорости, надёжности и функциональности. Возникает необходимость в
  автоматизации эксперимента, уменьшении человеческого фактора (ошибок, медленной реакции и~т.\,п.).
  \term{Автоматизация эксперимента}~--- комплекс
  средств и методов для ускорения сбора и обработки экспериментальный данных, интенсификации
  использования экспериментальных установок, повышения эффективности работы исследователей.
  Характерной особенностью автоматизации эксперимента является использование ЭВМ, что позволяет
  собирать, хранить и обрабатывать большое количество информации, управлять экспериментом в процессе
  его проведения, обслуживать одновременно несколько установок \cite{petronevich-automation,sokolov-auto-measure}.
  Аппаратные компоненты ИИС, в том числе особенности применения ЭВМ, рассмотрены в
  разделе~\ref{sec:hardware}.

  В настоящее время в измерительных информационных системах используются практически все типы
  серийно выпускаемых ЭВМ~--- от простейших настольных, переносных или встроенных персональных
  компьютеров до мощных рабочих станций и крупных вычислительных комплексов \cite[с.~149]{rannev-iis}.
  Чтобы применение ЭВМ действительно способствовало повышению эффективности измерений, к ЭВМ
  предъявляется важное требование: она должна работать в режиме \term{реального времени}
  \cite{tessier-reconfigurable}. В частности, недопустимы задержки отклика, которые могут приводить
  к потерям получаемых данных и некорректной привязке приходящих данных ко времени. С~другой
  стороны, увеличение точности по времени связано с увеличением частоты дискретизации, и, как
  следствие, количества обрабатываемых в единицу времени отсчётов данных. Это вынуждает либо искать
  компромисс между реальным временем и высокой пропускной способностью, либо повышать быстродействие
  ЭВМ, что включает в себя как использование более производительного аппаратного обеспечения, так и
  оптимизацию программного обеспечения.

  Помимо получения измерительных данных, ЭВМ также, в зависимости от решаемой задачи, может
  выполнять их преобразование, анализ, сохранение и визуальное представление, а также дальнейшую
  передачу по каналу связи. Из того, что эти процессы должны протекать одновременно и независимо,
  вытекает ещё одна особенность программного обеспечения для обработки измерительных данных~---
  необходимость использования \term{параллельных вычислений}. Это требование, как и требование
  быстродействия, влияет и на выбор аппаратного обеспечения, и на реализацию программного обеспечения.
  При этом важно понимать, что простое увеличение количества процессоров и использование
  многопоточности само по себе не гарантирует существенного ускорения работы программы. Возможность
  параллельного выполнения должна быть заложена в сам алгоритм, кроме того, требует осторожности
  работа с общими данными из нескольких потоков, чтобы избегать блокировок \cite{hoare-csp}.
  Функции программных компонентов ИИС и требования к ним, существующие программные решения и
  предлагаемые методы рассмотрены в разделе~\ref{sec:software}.

  Системы автоматизированной обработки измерительных данных находят применение в различных отраслях науки,
  в том числе, в геофизике (регистрация землетрясений и поиск полезных ископаемых), радиофизике,
  ядерной физике, физике полупроводников и многих других. Кроме экспериментальной науки ИИС
  применяются для управления и контроля за технологическими процессами, в специализированной
  измерительной технике.

  Целью данной работы является разработка универсальной информационной системы обработки
  измерительных данных~--- специализированного программного обеспечения, предназначенного для
  выполнения на ЭВМ, являющейся частью некоторой ИИС, с целью эффективной автоматизации процесса
  обработки экспериментальных данных. Для достижения цели ставятся следующие задачи:
  \begin{enumerate}
    \item Реализация процесса получения данных.
    \item Разработка высокопроизводительного модуля обработки цифровых данных.
    \item Реализация процесса синхронизации.
    \item Разработка подсистемы визуализации.
    \item Разработка модуля, позволяющего визуализировать ранее накопленные данные.
  \end{enumerate}
  Описанию архитектуры, реализации и тестирования системы, а также полученным результатам посвящён раздел~\ref{sec:my-system}.

  Объектом данного исследования являются экспериментальные данные и сигналы, используемые для их
  кодирования и передачи; а предметом исследования~--- способы повышения эффективности регистрации
  таких сигналов и обработки экспериментальных данных, в частности, программное обеспечение
  измерительных информационных систем, а также способы обработки цифровых сигналов.

  % TODO дополнить введение кратким упоминанием о результатах, достижениях?

  \section{Измерительные информационные системы}\label{sec:iis}

  % ------ begin section ------------

  Конец XX~-- начало XXI века характеризуются количественным и качественным развитием измерительных
  информационных систем во всем мире \cite[с.~3]{rannev-iis}. В наш век информационных
  технологий становится все более актуальным применение таких систем, так как они упрощают и облегчают доступ
  к необходимой информации, обеспечивают регулирование сложными технологическими процессами.
  Данный раздел содержит обзор предметной области информационных измерительных систем, включая цели
  и задачи их применения и требования, предъявляемые к ним.

  \term{Измерительная информационная система (ИИС)}~--- это совокупность функционально объединённых
  измерительных, вычислительных и других вспомогательных технических средств для получения
  измерительной информации, её преобразования, обработки с целью представления потребителю в
  требуемом виде, либо автоматического осуществления логических функций контроля, диагностики,
  распознавания и других функций \cite[с.~9]{volkov-iis}.
  Необходимые функциональные возможности и технические характеристики ИИС определяются
  \term{объектом исследования}, для которого данная система создаётся.

  Ниже приведены определения основных связанных понятий и рассмотрены особенности применения
  измерительных информационных систем.

  \subsection{Предметная область ИИС}

  Как уже было сказано выше, измерения в настоящее время применяются
  во многих отраслях науки, производства и быта. Современные задачи, возникающие в этих областях,
  и условия проведения научных экспериментов, а также проверок и испытаний образцов промышленной
  продукции связаны с необходимостью выполнения
  больших объёмов измерений разнообразных физических величин и технологических параметров.
  В~промышленности количество таких параметров может измеряться сотнями и тысячами.

  Для получения новых существенных результатов исследований, испытания сложных изделий, машин и
  оборудования к измерительной аппаратуре предъявляются все более жёсткие требования
  точности, достоверности результатов измерения, быстродействия. Это приводит к усложнению
  процесса обработки результатов измерений, которая при этом должна проводиться в реальном масштабе
  времени. Также необходима возможность адаптации процесса измерения к изменяющимся данным и условиям
  измерения прямо в процессе работы. Как следствие, увеличивается трудоёмкость и стоимость
  проведения измерительных процедур и эксперимента в целом. Для преодоления этих трудностей
  необходима разработка специальных измерительных информационных систем, построение которых
  невозможно без широкого использования современной вычислительной техники, в первую очередь,
  микропроцессорных технологий (микроконтроллеров, персональных компьютеров), а также развитых
  средств связи с объектами исследования и управления.

  Научно"=технический эксперимент, в отличие от производственно"=технологических процессов, имеет ряд
  особенностей, учёт которых необходим при проектировании ИИС, применяемых в этой области \cite[с.~17]{rannev-iis}.
  Часть из них перечислена ниже.
  \begin{enumerate}
    \item Большое разнообразие проводимых научно-технических экспериментов в сочетании с массовым
      характером их применения.
    \item Для исследований характерно изменение и усложнения методики эксперимента со временем,
      что может потребовать быстрой перестройки конфигурации системы, добавления новых функций.
    \item В одном эксперименте может одновременно использоваться большое число датчиков и
      исполнительных органов.
    \item Получаемые выборки данных имеют значительный объём.
    \item Исследуются сигналы в широком частотном спектр~--- от единиц герц до десятков и сотен
      мегагерц и выше.
  \end{enumerate}
  Для научных экспериментов также характерна широкая кооперация для проведения крупномасштабных
  исследований. Для обеспечения возможности объединения усилий разных исследователей существенно
  важна совместимость различных компонентов ИИС. Этому, в частности, способствует и использование
  программного обеспечения с открытым исходным кодом.

  Ниже приведены лишь некоторые основные понятия этой широкой предметной области.

  \term{Измерение}~--- нахождение значения физической величины опытным путём с помощью специальных
  технических средств. Измерение предполагает применение технического средства, хранящего единицу
  физической величины, для её сравнения с исследуемой физической величиной, и представление
  результата этого сравнения в виде числа.
  \term{Физическая величина}~--- одно из свойств физического объекта (физической системы, явления
  или процесса), общее в качественном отношении для многих физических объектов, а в количественном
  отношении индивидуальное для каждого из них \cite[с.~7]{rannev-iis}.

  \term{Метод измерения}~--- это совокупность некоторых принципов и средств измерений для
  определения значения величин. Под \term{принципом измерения} понимают совокупность физических явлений, на
  которых основаны измерения, а под \term{средствами измерений}~--- технические средства, используемые при
  измерениях и имеющие нормированные метрологические свойства. Измерение является
  многооперационной процедурой, и для его выполнения необходимо осуществление основных измерительных
  операций: воспроизведения, сравнения, измерительного преобразования и масштабирования.
  \term{Воспроизведение величины} заданного размера~--- это операция создания выходного сигнала с
  заданным размером информативного параметра. Она реализуется средством измерений~--- \term{мерой}.
  \term{Сравнение}~--- это определение соотношения между однородными величинами, осуществляемое
  путём их вычитания. Данная операция реализуется устройством сравнения (компаратором).
  \term{Измерительное преобразование}~--- операция преобразования входного сигнала в выходной,
  реализуемая измерительным преобразователем. Выходные сигналы измерительных преобразователей и их
  информативные параметры унифицированы.
  \term{Масштабирование}~--- это создание выходного сигнала, однородного с входным и
  пропорционального ему по размеру информативного параметра. Масштабное преобразование реализуется
  в~устройстве, которое называется масштабным преобразователем \cite[с.~16]{volkov-iis}.
  В~упрощённом виде алгоритм процесса измерения представлен на рис.~\ref{fig:meas-algo}.

  \begin{myfigure}{Структурная схема алгоритма измерения}{fig:meas-algo}
    \begin{tikzpicture}[scale=1.0, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{onarrow} = [pos=0.5, font=\footnotesize]
      \tikzstyle{item}  = [text centered, font=\footnotesize]
      \tikzstyle{block} = [item, theme1, rectangle, rounded corners, text width=3cm]
      \tikzstyle{cond}  = [item, theme2, diamond, aspect=1.5, text width=2cm]

      \node[block] (meas) {Измерение};
      \node[cond]  (check) [below=of meas]  {Сравнение с мерой};
      \node[block] (res)   [below=of check] {Отображение информации};
      \node[block] (corr)  [right= of check]  {Корректировка алгоритма измерения};

      \draw[arrow] (meas)  -- (check);
      \draw[arrow] (check) -- (res)  node[onarrow,left] {Да};
      \draw[arrow] (check) -- (corr) node[onarrow,below]{Нет};
      \draw[arrow] (corr)  |- (meas);
    \end{tikzpicture}
  \end{myfigure}

  Рассмотрим также некоторые термины, связанные непосредственно с самими измерительными информационными
  системами.

  \term{Вход ИИС}~--- часть системы или входящего в неё устройства, на которую непосредственно
  подаётся воздействие извне (то есть которая получает входящую информацию).
  \term{Выход ИИС}~---часть системы или входящего в неё устройства, которая в соответствии с
  алгоритмом функционирования непосредственно воздействует вовне (то есть выдаёт обработанную информацию).
  \term{Сигнал}~--- обусловленное (заранее договорённое) состояние или изменение состояния
  представляющего параметра, отображающее информацию, которая содержится в воздействии (как правило,
  выражается некоторой математической функцией, однозначно отображающей изменения во времени
  представляющего параметра).
  \term{Канал связи}~--- совокупность линий связи и технических устройств на передающей и приёмной
  частях системы.

  \term{Техническое обеспечение ИИС}~--- комплекс технических средств, предназначенных для
  обеспечения работы измерительной информационной системы.
  \term{Информационное обеспечение ИИС}~--- совокупность системы классификации и кодирования
  технологической информации, сигналов, характеризующих состояние объекта,
  массивов данных и документов, необходимых для выполнения всех функций ИИС.
  \term{Математическое обеспечение ИИС}~--- совокупность методов, математических моделей и алгоритмов,
  необходимых для выполнения функций ИИС.
  \term{Программное обеспечение ИИС}~--- совокупность программ, обеспечивающих реализацию функций
  системы, заданное функционирование комплекса технических средств ИИС и контроль за процессом измерения.
  Схема взаимодействие этих составляющих ИИС представлена на рис.~\ref{fig:iis-components}.

  \begin{myfigure}{Схема взаимодействия основных компонентов измерительных информационных систем}{fig:iis-components}
    \begin{tikzpicture}[scale=1.0, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{biarrow}  = [<->, very thick]
      % block - общий стиль-предок для inblk и outblk
      \tikzstyle{block}  = [rectangle, rounded corners, text centered, font=\footnotesize,
                              text width=3cm]
      \tikzstyle{inblk}  = [block, theme1, minimum height=1.4cm]
      \tikzstyle{outblk} = [block, theme2]
      \tikzstyle{bigarrow}=[thick, theme0]
      \tikzstyle{around} = [rectangle, rounded corners, draw=darkgray, loosely dashed]

      \node[inblk] (in) {Входная\\информация};
      \node[inblk] (inf) [right=3mm of in]{Информационное\\обеспечение};
      \node[inblk] (out) [right=3mm of inf]{Выходная информация};

      \node[outblk] (tech) [below=1.7cm of inf.west] {Техническое\\обеспечение};
      \node[outblk] (soft) [right=1cm of tech] {Программное\\обеспечение};
      \node[outblk] (pers) [above=1.7cm of out.west] {Оперативный\\персонал};
      \node[outblk] (org)  [left=1cm of pers] {Организационное\\обеспечение};

      \draw[arrow] (org) -- (pers);
      \draw[arrow] (soft) -- (tech);
      \draw[biarrow] ($(inf.west)+(0,-1cm)$) -- (tech);
      \draw[biarrow] ($(out.west)+(0, 1cm)$) -- (pers);

      \begin{pgfonlayer}{background}
        \node[fit=(org)(pers)(tech)(soft),around,label={[font=\small]below:Метрологическое обеспечение}] (title) {\hspace*{\fill}~}; % hspace - хак, чтобы подавить underfull hbox

        \draw[bigarrow] ($(in.north west) + (-3mm,3mm)$) -- ($(in.south west) + (-3mm,-3mm)$) --
                        ($(out.south east) + (-3mm,-3mm)$) -- ++(0, -0.5cm) --
                        ($(out.east) + (2cm, 0)$) -- ($(out.north east) + (-3mm,0.8cm)$) --
                        ++(0cm, -0.5cm) -- cycle;
      \end{pgfonlayer}

    \end{tikzpicture}
  \end{myfigure}

  \term{Совместимость ИИС}~--- возможность взаимосвязанного функционирования измерительных систем разных уровней и
  различного функционального назначения.
  \term{Надёжность ИИС}~--- способность ИИС выполнять функции, сохраняя эксплуатационные показатели
  в установленных пределах в течение заданного интервала времени при заданных условиях эксплуатации.
  Надёжность характеризуется показателями безотказности, ремонтопригодности и долговечности
  \cite[с.~5--7]{rannev-iis}.

  % TODO классификация ИИС?
  Выделим особо некоторые разновидности измерительных информационных систем.

  \term{Измерительно-вычислительный комплекс (ИВК)}~--- одна из разновидностей ИИС, функционально
  объединённая с помощью специальной многоканальной магистрали совокупность средств
  измерений, вычислительной техники, устройств отображения информации и вспомогательных устройств,
  предназначенная для выполнения конкретной измерительной задачи. Основными признаками
  принадлежности измерительной системы к ИВК являются: наличие компьютера, программное управление
  средствами измерений, нормированные метрологические характеристики, блочно-модульная структура \cite[с.~225]{rannev-iis}.

  \term{Виртуальные приборы (англ.~\eng{virtual instruments})}~--- понятие, появившееся на стыке
  измерительной информационной и компьютерной техники. Виртуальный информационно-измерительный
  прибор или система — это компьютер, оснащённый набором аппаратных и программных средств,
  выполняющий функции информационно-измерительного прибора или системы и максимально приближенный к
  решению задачи. При этом часть функций и операций осуществляется не аппаратно, а программно с
  помощью персонального компьютера \cite[с.~209]{rannev-iis}. Примером программного обеспечения для
  реализации виртуальных приборов является пакет LabVIEW \cite{lavrov-labview}. Подробнее подобное
  ПО рассмотрено ниже, в подразделе \ref{ssec:existing}.

  \subsection{Цели и задачи применения ИИС}\label{ssec:iis-goals}

  Спектр отраслей, в которых применяются измерительные информационные системы весьма широк.
  В частности, ИИС применяются для решения задач управления технологическими и
  производственными процессами (например, атомными электростанциями и ТЭЦ), для автоматизации экспериментальных
  исследований (в ядерной физике, аэродинамике и многих других областях науки), для испытаний, мониторинга,
  диагностики и тестирования аппаратных средств (отдельных агрегатов и целых машин, например, самолётов). В
  каждой из этих областей объектам и явлениям присущи некоторые отличительные особенности, которые
  предъявляют к измерительной системе свои характерные требования. Но несмотря на эти различия,
  для всех ИИС характерны общие тенденции развития, принципы построения и подходы к проектированию.
  % \cite[с.~24]{rannev-iis}

  Основная цель применения измерительных информационных систем~--- повышение эффективности и
  достоверности процесса измерения за счёт его автоматизации. В~данном случае автоматизация, с одной
  стороны, позволяет исключить негативное влияние человеческого фактора (невнимательности, ошибок)
  на процесс измерения, а с~другой~--- открывает возможности, которые в принципе недоступны без
  использования вычислительных технологий (такие как, например, обработка больших объёмов информации
  в реальном времени или способность менять алгоритмы обработки в зависимости от характера входных данных).
  % TODO это фразы от себя! Нужны источники

  Назначение любой измерительной информационной системы можно определить как целенаправленное
  оптимальное ведение измерительного процесса и обеспечение смежных систем высшего уровня
  достоверной информацией. Исходя из этого, основные функции
  измерительной информационной системы \cite[с.~397]{rannev-meas-tech}:
  \begin{itemize}
    \item получение измерительной информации от объекта исследования;
    \item обработка информации;
    \item сохранение информации;
    \item представление информации оператору;
    \item дальнейшая передача информации;
    \item формирование управляющих воздействий.
  \end{itemize}
  В графическом виде эти основные функции представлены на рис.~\ref{fig:iis-functions}.

  \begin{myfigure}{Основные функции ИИС, наиболее фундаментальные выделены}{fig:iis-functions}
    \begin{tikzpicture}[scale=0.9, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{block} = [rectangle, theme1, rounded corners, minimum height=2em,
                           text width=3cm, text centered, font=\small]
      \tikzstyle{main}  = [theme1a, font=\small\bfseries]
      \node[block,main] (rcv)  {Получение};
      \node[block,main] (proc) [right=1cm of rcv]  {Обработка};
      \node[block,main] (save) [below=5mm of proc] {Сохранение};
      \node[block]      (tran) [right=1cm of proc] {Передача};
      \node[block]      (disp) [above=5mm of tran] {Отображение};
      \node[block]      (ctrl) [above=5mm of rcv]  {Управление};

      \draw[arrow] (rcv) -- (proc);
      \foreach \to in {save, tran}
        \draw[arrow] (proc) -- (\to);
      \foreach \from/\to in {proc.140/ctrl, proc.40/disp}
        \draw[arrow] (\from) |- (\to);
      \draw[arrow, <-] (rcv.west)  -- ++(-5mm, 0);
      \draw[arrow]     (ctrl.west) -- ++(-5mm, 0);
      \draw[arrow]     (tran.east) -- ++(5mm, 0);
    \end{tikzpicture}
  \end{myfigure}

  В зависимости от требований конкретной задачи, стоящей перед ИИС, этот краткий список функций
  может изменяться и пополняться. При этом первые три являются наиболее фундаментальными и
  присутствуют практически в любой развитой измерительной информационной системе. % TODO источник?

  \subsection{Требования, предъявляемые к ИИС}\label{ssec:iis-requirements}

  Поскольку одной из главных целей применения ИИС, как было сказано выше, является автоматизация процесса
  измерения, рассмотрим в первую очередь требования к самому процессу автоматизации в общем случае.

  Общие принципы и требования, предъявляемые к системам автоматизации эксперимента \cite{vinogradov-discrete, kurochkin-kamak}:
  \begin{itemize}
    \item высокое быстродействие, а именно, достаточное для получения и анализа данных и оперативного принятия решений;
    \item надёжность, возможность длительной безотказной работы;
    \item простота эксплуатации и использование унифицированных блоков;
    \item гибкость, допускающая изменение состава и структуры системы в~процессе работы;
    \item возможность коллективного обслуживания различных установок;
    \item наличие диалогового режим работы, когда осуществляется непосредственная связь человека с системой;
    \item простая и быстрая система контроля.
  \end{itemize}

  Всё это напрямую относится и к измерительным информационным системам.  Состав и структура
  конкретной ИИС определяются перечисленными выше техническими требованиями, установленными
  государственным стандартом, и частными требованиями, содержащимися в техническом задании на её
  создание.

  Измерительная информационная система должна \cite[с.~28]{rannev-iis}:
  \begin{itemize}
    \item выполнять свои функции в соответствии с назначением и целью;
    \item управлять измерительным экспериментом согласно принятому алгоритму функционирования;
    \item обладать требуемыми показателями и характеристиками точности, надёжности и быстродействия;
    \item отвечать экономическим требованиям, предъявляемым к способам и форме представления
      информации, размещению технических средств; % TODO что это значит ???
    \item быть приспособленной к взаимодействию с другими ИИС, то есть обладать свойством программной, технической, информационной и метрологической
      совместимости;
    \item допускать возможность дальнейшей модернизации и развития.
  \end{itemize}

  В следующем подразделе вводится понятие измерительного канала, приведено сравнение одноканальных
  и многоканальных измерительных информационных систем и показано, как требования, перечисленные
  выше, влияют на выбор между ними.

  \subsection{Одноканальные и многоканальные ИИС}\label{ssec:multichannel}

  \term{Измерительный канал} измерительной системы~--- это конструктивно или функционально
  выделяемая часть ИИС, выполняющая законченную функцию от восприятия измеряемой величины до
  получения результата её измерений, выражаемого числом или соответствующим ему кодом
  \cite[с.~9]{volkov-iis}. Иначе говоря, под измерительным каналом понимается совокупность
  технических средств и линий дистанционной передачи между первичным преобразователем (датчиком), измерительным
  устройством и устройством отображения информации \cite[с.~420]{rannev-meas-tech}. Техническое
  устройство измерительного канала подробнее рассмотрено далее, в разделе~\ref{sec:hardware}.

  Различают простые измерительные каналы, реализующие прямые измерения какой-либо величины, и
  сложные измерительные каналы, содержащие несколько простых измерительных каналов для реализации
  косвенных, совокупных или совместных измерений. Например, при измерениях мощности в электрических
  сетях начальная часть сложного измерительного канала состоит из простых каналов измерения
  напряжения и тока.

  По количеству каналов ИИС можно разделить на \term{одноканальные} и \term{многоканальные}. Многоканальные ИИС
  параллельного действия являются более распространёнными, так как имеют ряд преимуществ перед
  одноканальными: обладают наиболее высокой надёжностью, высоким быстродействием, дают возможность
  подбирать средства измерений к измеряемым величинам
  \cite[с.~171]{rannev-iis}.

  Основные достоинства многоканальных измерительных систем связаны с возможностью измерения
  разнородных физических величин, достижения
  максимального быстродействия и высокой схемной надёжности. При этом надёжность многоканальных ИИС
  оценивается по-разному в зависимости от предъявляемых к ним требований. Если считать, что система
  работоспособна только при исправности всех входящих в нее элементов, то тогда (при одинаковых
  измерительных каналах) вероятность безотказной работы такой структуры может быть относительно
  низкой. Однако если важна работоспособность хотя бы одного канала, то в этом случае надёжность
  будет выше по сравнению с одноканальными системами, так как каналы дублируют друг друга.

  Недостатком многоканальных измерительных систем является большее (по сравнению с
  другими типами ИИС) число элементов, что может быть причиной более высокой стоимости. Впрочем, в
  последнее время в связи с развитием и удешевлением цифровой техники \cite{rathore-digital} этот недостаток
  перестаёт быть существенным.

  % TODO рассказать про мультиплицированные ИИС? (они, по-видимому, не цифровые => не сильно интересно)

  % ------ end section ------------

  \paragraph{Выводы к разделу.}
  Таким образом, в данном разделе было введено понятие измерительных информационных
  систем и связанные с ним определения, описана предметная область ИИС. Рассмотрены
  основные требования, предъявляемые к таким системам и показано, почему для их удовлетворения более
  предпочтительными являются многоканальные ИИС.

  В следующем разделе рассмотрены технические особенности построения измерительных систем,
  использование микроконтроллеров в них, виды цифровой обработки сигналов, а также способы
  синхронизации.

  \section{Аппаратные компоненты ИИС}\label{sec:hardware}

  Надёжная и эффективная работа ИИС в первую очередь определяется достоверностью информации,
  получаемой об исследуемом объекте. Выше были рассмотрены общие принципы автоматизации и
  требования, которые исходя из этого предъявляются к измерительным информационным системам.
  В данном разделе показано, как эти требования определяют техническое обеспечение измерительных систем: описаны входящие в их
  состав аппаратные компоненты, приведена структура измерительных каналов ИИС, а~также всей системы
  в целом. Наиболее важные компоненты рассмотрены отдельно.

  % ------ begin section ------------

  В состав измерительной информационной системы могут входит компоненты следующих типов
  \cite[с.~15]{volkov-iis}.
  \begin{enumerate}
    \item Первичные измерительные преобразователи (датчики).
    \item Измерительные преобразователи, масштабные преобразователи.
    \item Аналого-цифровые преобразователи.
    \item Цифровые устройства:
      \begin{enumerate}
        \item формирователи импульсов;
        \item преобразователи кодов;
        \item коммутаторы;
        \item устройства памяти;
        \item устройства сравнения кодов;
        \item универсальные программируемые вычислительные устройства~--- микропроцессоры, микроЭВМ;
        \item специализированные цифровые вычислительные устройства.
      \end{enumerate}
    \item Устройства вывода, отображения и регистрации.
    \item Интерфейсные устройства, служащие для приёма командных сигналов и передачи информации о
      состоянии блоков;
    \item Устройства управления, формирующие командную информацию, принимающее информацию от
      функциональных блоков и подающее команды на исполнительные устройства для формирования
      воздействия на объект исследования.
    \item Связи между вышеперечисленными устройствами.
  \end{enumerate}

  \subsection{Структура измерительной системы}\label{ssec:iis-structure}

  Перечисленные в подразделе~\ref{ssec:iis-requirements} принципы позволяют сформировать наиболее
  общую структуру автоматизированной системы управления экспериментом (рис.~\ref{fig:system-structure}).

  \begin{myfigure}{Структурная схема автоматизированной системы измерений}{fig:system-structure}
    \begin{tikzpicture}[scale=0.9, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      % item - общий стиль-предок для block, comp, control и user
      \tikzstyle{item}   = [rectangle, rounded corners, text centered, font=\footnotesize]
      \tikzstyle{block}  = [item, theme1, text width=2.5cm, minimum height=4em]
      \tikzstyle{comp}   = [item, theme2, text width=2cm, font=\small, minimum height=8em]
      \tikzstyle{object} = [circle, theme3, text centered, text width=2.2cm, font=\footnotesize]
                            % minimum height должна совпадать с той, что у block
      \tikzstyle{control}= [item, theme2, text width=4cm]
      \tikzstyle{user}   = [item, theme3, inner sep=5mm]
      % Блоки верхнего ряда (b = block)
      \node[object] (b0) {Исследуемый\\объект};
      \node[block]  (b1) [right=0.75cm of b0] {Датчики\\физических\\величин};
      \node[block]  (b2) [right=0.75cm of b1] {Каналы\\измерений};
      \node[block]  (b3) [right=0.75cm of b2] {Канал связи};
      % Большой блок "ЭВМ" (comp = computer)
      \node[comp] (Comp) [right=0.75cm of b3, shift={(0,-1)}] {ЭВМ};
      % Узлы для стрелок под блоками
      \foreach \x in {1,...,3} {
        \node (u\x)[below=of b\x] {};
      }
      % Узел под b0 располагаем с осторожностью: b0 имеет другую высоту
      \node (u0) at (u1-|b0) {};  % ( A -| B ) - точка с y-координатой от A и x-координатой от B
      % Стрелки под блоками
      \foreach \x in {0,...,3} {
        \draw [arrow] (u\x.north) -- (b\x);
      }
      % Нижняя объемлющая часть стрелки
      \draw [-, thick] (b0) -- (u0.north) -- (u0.north-|Comp.west) % ( A -| B ) - точка с y-координатой от A и x-координатой от B
            node[midway, below, font=\footnotesize] (Label) {Канал обратной связи};
      % Стрелки между блоками
      \foreach \from/\to in {b0/b1, b1/b2, b2/b3}
        \draw [arrow] (\from) -- (\to);
      % Горизонтальная стрелка между последним блоком и ЭВМ
      \draw [arrow] (b3) -- (b3-|Comp.west);

      \node[control] (Control) [below=0.5cm of  Label ] {Пульт контроля\\и управления};
      \node[user]    (User)    [below=0.75cm of Control] {Исследователь};

      \draw [<->, very thick, blue!50!black] (Comp) |- (Control);
      \draw [<->, ultra thick, brown!75!violet] (User) -- (Control);

      \draw [<-, very thick, red] (b0.west) -- ++(-0.5cm, 0cm) |- (Control);

    \end{tikzpicture}
  \end{myfigure}

  Данные об исследуемом объекте от специализированных датчиков физических величин
  поступают на вход каналов измерения, которые выполняют функции фильтрации, масштабирования,
  аналого-цифрового преобразования, коррекции данных. Затем данные по каналам связи поступают в
  ЭВМ, где происходит их основная обработка в соответствии с заданными математическими алгоритмами.
  При этом исследователь может следить за процессом обработки с помощью пульта контроля и управления, что
  позволяет в реальном масштабе времени вносить необходимые коррективы как в алгоритмы обработки,
  так и в процесс управления всей системой. Вся измерительная система охвачена каналом
  обратной связи, что позволяет напрямую управлять каждым из компонентов системы от ЭВМ
  \cite{kuzmichev-automation}.

  При практической реализации ИИС канал измерения представляет собой
  наиболее сложный узел, так как он определяет метрологические характеристики всей системы.
  Функции измерительного канала были описаны выше, в подразделе~\ref{ssec:multichannel},
  там же были показана важность многоканальных измерительных систем.
  Типичная схема реализации измерительного канала приведена на рис.~\ref{fig:channel-scheme}.

  \begin{myfigure}{Функциональная схема канала измерения}{fig:channel-scheme}
    \begin{tikzpicture}[scale=0.9, transform shape]
      \tikzstyle{block} = [rectangle, theme1, rectangle, rounded corners,
                           text centered, text width=3cm, font=\footnotesize, minimum height=4em]
      \tikzstyle{around} = [rectangle, draw=darkgray, loosely dashed, rectangle, rounded corners]
      % Блоки (c = channel)
      \node        (c0) {};
      \node[block] (c1) [right=0.5cm of c0] {Масштабный преобразователь};
      \node[block] (c2) [right=0.7cm of c1] {Устройство фильтрации};
      \node[block] (c3) [right=0.7cm of c2] {Аналогово-цифровой \mbox{преобразователь}}; % mbox чтобы избежать переноса
      \node[block] (c4) [right=0.7cm of c3] {Устройство управления};
      \node        (c5) [right=0.5cm of c4] {};

      \node[above=of current bounding box.center] (title) {Измерительный канал};

      % Стрелки под блоками
      \foreach \x in {1,...,3} {
        \node (u\x)[below=of c\x] {};
        \draw [->, thick] (c4) |- (u\x.north) -- (c\x);
      }

      \foreach \from/\to in {c0/c1, c1/c2, c2/c3, c3/c4, c4/c5}
        \draw [->, thick] (\from) -- (\to);

      \node[fit=(c0)(c3)(c5)(u1)(title),around]{\hspace*{\fill}~}; % hspace - хак, чтобы подавить underfull hbox
    \end{tikzpicture}
  \end{myfigure}

  При такой схеме данные с датчика физических величин поступают на масштабный преобразователь (например, усилитель),
  назначение которого связанно с преобразованием уровня аналогового сигнала до приемлемого значения.
  Далее аналоговый сигнал поступает на устройство фильтрации, которое в общем случае может состоять
  из разных по назначению фильтров, построенных как по аналоговой схеме, так и по цифровой. После
  фильтрации сигнал поступает на аналого-цифровой преобразователь (АЦП), выполняющий
  функцию дискретизации аналогового сигнала. Устройство управления канала измерения
  выполняет функцию контроля и управления входящими в канал устройствами.

  Такое построение позволяет
  достаточно просто реализовать канал измерения, однако не обеспечивает решения всего спектра
  возможных измерительных задач. Действительно, использование раздельного управления в каждом канале
  измерения, с одной стороны, требует усложнения общего управления всеми каналами измерения (требует
  настройки каждого канала измерения по отдельности), с другой стороны, не позволяет точно
  синхронизировать измерения по каналам, и в третьих, в силу отсутствия промежуточных вычислительных
  процессоров, не позволяет всей автоматизированной системе в реальном времени реагировать на
  изменение входной информации \cite{stupin-methods}.

  Одним из решений указанных проблем является применение оптимальных программно-аппаратных
  алгоритмов обработки информации с точной синхронизацией по времени  обработки сигналов,
  что становится возможным благодаря использованию вычислительных процессоров и специализированных инструментальных средств.

  \subsection{Применение вычислительных процессоров}

  Далее рассмотрены общие принципы применения микропроцессоров в измерительных системах, после чего
  с их учётом предложена альтернативная схема канала измерения, не имеющая вышеперечисленных недостатков.

  Уменьшение размеров микропроцессоров и снижение их стоимости в последние десятилетия обеспечили
  возможность широкого использования их в разнообразных приборах и устройствах. Это касается и
  измерительной техники: как показано ниже, использование в них микропроцессоров может
  способствовать повышению производительности, надёжности и функциональности. При этом, безусловно,
  их наличие не является обязательным: в простых случаях измерительный прибор может быть успешно реализован
  и без использования микропроцессорных технологий, то есть построен на обычных, не программируемых
  интегральных схемах. Применение микропроцессоров оправдано в следующих случаях~\cite[с.~241]{rannev-meas-tech}.
  \begin{enumerate}
    \item Если для решения задачи без использования микропроцессоров требуется большое число интегральных
      схем (больше, чем 30--50).
    \item Если измерительный прибор является многофункциональным.
    \item Если предвидится дальнейшее расширение системы, добавление новых функций.
    \item Если измерительная система взаимодействует с большим числом входных и выходных устройств.
    \item Если в процессе работы необходимо сохранение в памяти больших объёмов данных.
    \item Если требуется статистическая обработка результатов измерения (или другие математические расчёты).
    \item Если есть необходимость в функциях самокалибровки и самодиагностики.
  \end{enumerate}
  Эти и другие частные случаям можно обобщить: применение микропроцессоров оправдано, если требуемые
  характеристики (точность, быстродействие, метрологические характеристики) средствами обычных
  интегральных схем достичь невозможно (либо это связано с существенными затруднениями).

  \subsubsection{Функции микропроцессоров}\label{sssec:mcu-functions}

  Микропроцессоры и микроЭВМ в ИИС используются для объединения приборов в единый комплекс и выполнения
  \term{контроллерных}, \term{вычислительных}, \term{тестовых}, \term{сервисных} функций, а также
  функций \term{распределённой обработки данных}~\cite[с.~421]{rannev-meas-tech}.
  Далее подробно рассмотрен каждый из этих классов функций, и для каждого из них показано, какие
  преимущества предоставляет их наличие (по сравнению с ИИС без использования микропроцессоров).

  \paragraph{Контроллерные функции} связаны с формированием управляющих воздействий для устройств,
  входящих в канал измерения, а также для других компонентов ИИС. Контроллерные функции можно
  подразделить на следующий ряд подфункций.
  \begin{enumerate}
    \item Управление измерительной цепью, например, переключение каналов и диапазонов, изменение
      параметров фильтров, управление масштабными преобразователями, и~т.~п.
    \item Управление аналого-цифровым преобразованием.
    \item Управление средствами представления информации оператору (клавиатурой, индикаторами,
      звуковой сигнализацией и дисплеем).
    \item Управление регистраторами (принтерами, самописцами, графопостроителями,
      накопителями на магнитных носителях).
    \item Управление внешней памятью.
  \end{enumerate}

  Благодаря выполнению этих функций применение микропроцессоров способствует увеличению
  функциональности измерительной системы, расширяет спектр совместимых с ней устройств.

  \paragraph{Вычислительные функции} обеспечивают обработку данных: первичную, вторичную и
  окончательную. К таким функциям относятся калибровка, нормализация, масштабирование, фильтрация,
  сжатие данных, распознавание образов, устранение ошибок и подавление помех, спектральный,
  корреляционный и статистический анализ и многие другие. Подробнее цифровая обработка сигналов
  рассмотрена далее, в подразделе~\ref{ssec:signal-processing}. Впрочем, многие из этих функций
  необязательно должны выполняться микропроцессором (то есть программно), они могут быть реализованы
  и аппаратно, устройствами, входящими в канал измерения (фильтрация~--- аналоговыми фильтрами,
  масштабирование~--- масштабными преобразователями, и~т.~д.), которые были рассмотрены выше, в
  подразделе~\ref{ssec:iis-structure}.

  Эти функции, как и контроллерные, способствуют расширению функциональности ИИС, а также повышению
  точности и надёжности. Например, точность может быть увеличена благодаря цифровым методам
  коррекции систематических и случайных погрешностей, а надёжность~--- с помощью переноса части
  функций (например, фильтрации) с ненадёжных аналоговых элементов на высоконадёжные цифровые.

  \paragraph{Тестовые функции} включают обнаружение и локализацию неисправностей в системе.
  Тестирование может либо выполняться с применением внешних микропроцессорных средств, либо быть
  полностью автономным, либо представлять собой комбинацию этих двух способов. В первом случае
  применяются специализированные \term{тестеры} с микроЭВМ, в которых и реализована программа
  тестирования. Во втором случае функции тестирования обычно выполняет либо основной процессор
  измерительной системы (наиболее очевидное решение), либо специально выделенный для этого
  микропроцессор в составе ИИС.

  Наличие в системе этих функций, реализация которых без микропроцессора затруднительна,
  повышает надёжность системы.

  \paragraph{Сервисные функции} расширяют основную функциональность измерительной системы
  дополнительными возможностями. Сюда относятся вторичная обработка и интерпретация результатов,
  генерация отчётов для интерпретации, документации и архивации.

  Наличие этих функций не является обязательным для измерительной системы, но в случае сложных
  систем они значительно облегчают взаимодействие пользователя с системой.

  \paragraph{Распределённая обработка данных} подразумевает распределение вычислительных задач между
  узлами системы. Под распределённой обработкой может подразумеваться как разделение разных задач
  между разными устройствами для независимого выполнения, так и параллельное выполнение одной задачи
  на нескольких процессорах для повышения производительности.

  Параллельное выполнение обработки данных несколькими программируемыми
  контроллерами повышает надёжность и быстродействие системы.

  \paragraph{Преимущества применения микропроцессоров.}
  Для каждого из класса функций выше были перечислены преимущества, которые они привносят в ИИС.
  Подводя итог, следует отметить, что использование микропроцессоров в измерительных информационных системах способствует
  повышению точности, помехоустойчивости, быстродействия, надёжности, а также расширяет набор
  функциональных возможностей ИИС, в том числе связанных с представлением информации пользователю
  и передачей информации по каналам связи \cite{klaassen-methods}.

  \subsubsection{Канал измерения с применением микроконтроллера}

  Перейдём теперь от общих принципов к их применению для построения измерительного канала.

  Перспективным решением является схема построения каналов измерения, в которой
  используется промежуточная микроЭВМ, в качестве которой могут быть применены как
  специализированные цифровые устройства, так и микроконтроллеры или цифровые сигнальные процессоры.
  Кроме перечисленных выше общих преимуществ применения микропроцессоров, в данном случае это также
  позволяет синхронизировать отдельные процессы обработки информации по времени. Задача синхронной обработки информации
  является важной ещё и потому, что применение цифровых фильтров при обработке измерительной
  информации в общем случае может приводить к рассинхронизации измерительной информации по отдельным
  измерительным каналам, связанной с различной задержкой во времени прохождения сигналов по
  измерительному тракту.

  Функциональная схема каналов измерения с применением микроконтроллера  представлена на
  рис.~\ref{fig:channel-with-microcontroller}.

  \begin{myfigure}{Схема каналов измерения с применением микроконтроллера}{fig:channel-with-microcontroller}
    \begin{tikzpicture}[scale=0.85, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{cline}  = [thick, Blue] % линия управления: толстый синий
      \tikzstyle{sline}  = [thick, Red] % линия синхронизации толстый синий
      \tikzstyle{item}   = [rectangle, rounded corners, text centered, font=\footnotesize]
      \tikzstyle{block}  = [item, theme1, text width=3cm, minimum height=4em]
      \tikzstyle{around} = [item, draw=darkgray, loosely dashed]
      \tikzstyle{title}  = [above, font=\small]
      \tikzstyle{controller} = [item, theme2, thick, text width=3cm, minimum height=2.5cm]
      \tikzstyle{syncdev}= [item, theme3, text width=2.5cm]
      \tikzstyle{ram}    = [cylinder, theme3, aspect=0.25, inner sep=3mm, shape border rotate=90, text centered, font=\footnotesize]
      \tikzstyle{empty}  = [fill=none, draw=none, inner sep=0mm]

      % Блоки (c = channel, cIJ - канал номер I, блок номер J)
      % Задаём вручную начальные позиции каналов
      \node[empty] (c10) {};
      \node[empty] (c20) [below=3.5cm of c10] {};
      \node[empty] (cN0) [below=3.5cm of c20] {};
      % Всё остальное рисуем в цикле:
      \foreach \x in {1, 2, N} {
        \node[block] (c\x1) [right=0.5cm of c\x0] {Масштабный преобразователь};
        \node[block] (c\x2) [right=0.7cm of c\x1] {Устройство фильтрации};
        \node[block] (c\x3) [right=0.7cm of c\x2] {Аналогово-цифровой \mbox{преобразователь}}; % mbox чтобы избежать переноса
        \node[title] (title\x) at (c\x2.north) {Измерительный канал №$\x$};
        \foreach \from/\to in {c\x0/c\x1, c\x1/c\x2, c\x2/c\x3}
          \draw [arrow] (\from) -- (\to);
        % Узлы под боками (u = under, uIJ)
        \foreach \y in {1,2} {
          \node[empty] (u\x\y)[below=3mm of c\x\y] {};
        }
        % u3 отдельно: он ниже
        \node[empty] (u\x3)[below=6mm of c\x3] {};
        \node[fit=(c\x1)(c\x3)(u\x1)(title\x),around]{\hspace*{\fill}~}; % hspace - хак, чтобы подавить underfull hbox
      }
      \node[controller] (MCU) [right=2.5cm of c23] {Микроконтроллер};
      % Входы в контроллер: mc1, mc2, mcN
      \foreach \x/\angle in {1/160, 2/180, N/200} {
        \node (mc\x) [left=1cm of MCU.\angle] {};
        \draw [arrow] (c\x3) -| (mc\x.center) -- (mc\x.center -| MCU.west);
      }
      % Линия управления
      \node[circle,fill=Blue,inner sep=1mm] (Control) [right=4mm of u11-|mc1] {};
      \node[above right, Blue, font=\footnotesize] at (Control) {Линия управления};
      \draw [-, cline] (MCU) |- (Control);
      % Линия синхронизации
      \node[circle,fill=Red,inner sep=1mm] (Sync) [left=4mm of u23-|mc2] {};
      \node[below right, Red, font=\footnotesize] at (Sync-|Control) {Линия синхронизации};
      \draw [-, sline] (MCU) |- (Sync);
      % Соединяем линии синхронизации и управления с блоками
      \foreach \x in {1,2,N} {
        % Стрелки линии управления
        \foreach \y in {1,2} {
          \draw [->, cline] (Control) |- (u\x\y.center) -- (c\x\y);
        }
        % Стрелки линии синхронизации
        \draw [->, sline] (Sync) |- (u\x3.center) -- (c\x3);
      }
      % Устройство синхронизации
      \node[syncdev] (SyncDev) [below=2cm of MCU] {Устройство синхронизации};
      \draw[<-, thick, theme3, fill=none] (MCU.340) -- ++(4mm,0mm) |- (SyncDev);
      % ОЗУ
      \node[ram] (RAM) [above=2.2cm of MCU] {ОЗУ};
      \draw[<->, thick, theme3, fill=none] (MCU.20) -- ++(4mm, 0mm) |- (RAM);
      % Выход
      \draw[arrow] (MCU.east) -- ++(1, 0);

    \end{tikzpicture}
  \end{myfigure}

  Данные от датчиков физических величин поступают на масштабные преобразователи измерительных
  каналов. Использование при этом микроконтроллера с обратной связью позволяет повысить точность
  измерения входных величин за счёт разделения информации по каналам
  измерения с разным коэффициентом усиления и её сложением в микроконтроллере. В этом случае часть
  измерительных каналов работает с б\'{о}льшим сигналом, а часть настроена на малый сигнал, что
  позволяет измерять аналоговые сигналы в большом диапазоне значений, при этом на выходе
  микроконтроллера получается непрерывный сигнал во всем диапазоне значений физических датчиков.
  Устройства фильтрации также управляются от микроконтроллера, что позволяет не только выполнять
  стандартные операции фильтрации сигнала, но и оперативно реагировать на изменяющиеся помехи и адаптировать параметры
  фильтрации, что существенно увеличивает общую помехоустойчивость процесса измерения сигналов.

  Отфильтрованные данные поступают на аналого-цифровые преобразователи, которые, в свою очередь,
  управляются по линии синхронизации. Это позволяет решить задачу синхронной дискретизации сигналов
  по времени, при этом точность синхронизации будет определяться, в первую очередь, точностью
  устройства синхронизации, в качестве которого могут использоваться как классические источники
  высокоточных синхроимпульсов, так и генераторы синхроимпульсов, построенные с использованием
  глобальной системы позиционирования (GPS). Устройство синхронизации рассмотрено далее, в
  подразделе \ref{ssec:sync}.

  Информация, поступающая на входы микроконтроллера в цифровом виде от аналого-цифровых
  преобразователей может как передаваться далее по линиями связи в основную ЭВМ, так и
  накапливаться во временном оперативном запоминающем устройстве. Это позволяет, с одной стороны,
  применять специализированные алгоритмы обработки информации с целью оперативного управления
  масштабными преобразователями и устройствами фильтрации, а с другой~--- за счёт применения
  высокоскоростных параллельных ОЗУ накапливать данные со скоростью, превосходящей возможности
  каналов связи. Такое применение гарантирует, что в заданный промежуток времени весь поток
  поступающей информации будет обработан и в дальнейшем передан в ЭВМ для анализа и хранения.

  Применение микроконтроллеров в подготовке информации для передачи по каналам связи позволяет
  более полно использовать каждый физический канал связи, что в общем случае позволяет как добиться
  большей скорости передачи информации, так и существенно расширить спектр применяемых видов каналов
  связи: от радиоканала до специализированной вычислительной сети. Применение специализированных
  алгоритмов в подготовке данных позволяет добиться гарантированного прохождения информации по
  каналам связи без потерь, а применение алгоритмов шифрования и распределения доступа позволяет
  большему количеству исследователей одновременно участвовать в физических экспериментах, при этом
  гарантируется надёжность управления всей системой.

  Таким образом, применение микроконтроллеров в качестве управляющего устройства сразу в нескольких
  каналах измерения автоматизированных систем позволяет существенно расширить возможности самой
  системы, кардинально повысить помехоустойчивость системы, решить вопрос синхронизации поступающих
  данных и, как результат, добиться повышения эффективности и достоверности процессов обработки
  измерительных сигналов в измерительной системе.

  % TODO в следующий раздел? (тогда подправить выводы в конце раздела)
  \subsection{Цифровая обработка сигналов}\label{ssec:signal-processing}

  % TODO картинки в этот раздел?

  Выше, в п.~\ref{sssec:mcu-functions} было показано, что выполнение микропроцессором, входящим
  в~состав ИИС, определённых вычислительных функций способствуют повышению точности, надёжности и
  расширению функциональности измерительных систем. Для выполнения этих функций требуется реализация
  алгоритмов цифровой обработке сигналов, краткий обзор которых приводится далее.

  Одной из самых распространённых операций обработки сигналов является фильтрация. Цель
  фильтрации состоит в подавлении помех, содержащихся в сигнале, или в выделении отдельных
  составляющих сигнала, соответствующих тем или иным свойствам исследуемого процесса. Фильтрация
  сигнала заключается в целенаправленном изменении соотношения между различными компонентами спектра
  сигнала.

  Хотя фильтрация может производиться аналоговыми устройствами, реализация цифровой фильтрации имеет
  ряд преимуществ. Цифровые фильтры обладают высокой точностью, гибкостью настройки, их легко
  изменять в соответствии с требованиями задачи. В отличие от аналоговых
  фильтров передаточная функция не зависит от дрейфа характеристик элементов. Но, несмотря на
  вышеперечисленные плюсы, цифровая фильтрация имеет и недостатки. Это, во-первых, трудность работы с
  высокочастотными сигналами: полоса частот ограничена частотой Найквиста, равной половине частоты
  дискретизации сигнала. Во-вторых, трудность работы в реальном времени~--- вычисления должны быть завершены в
  течение периода дискретизации. Для большей точности и высокой скорости обработки сигналов
  требуется не только мощный процессор, но и дополнительное, дорогостоящее, аппаратное обеспечение в
  виде высокоскоростных ЦАП и АЦП \cite{glinchenko-digital}.

  Для фильтрации и других видов анализа сигнала широко используется представление сигнала в
  частотной области, то есть анализ его спектра. \term{Дискретное преобразование Фурье} (ДПФ) может быть использовано для вычисления
  гармонических составляющих спектра по заданным дискретным отчётам аналогового сигнала, которые
  затем используются для осуществления фильтрации или выявления особенностей сигнала. Этот
  алгоритм имеет довольно большую вычислительную сложность: для определения одного коэффициента ДПФ
  сигнальной последовательности из $N$ отчётов необходимо выполнить около $N$ операций умножения на
  комплексное число и столько же сложений, а для нахождения всех коэффициентов объем вычислений
  составит $N^2$ \cite{solonina-algorithms}.

  Этого недостатка не имеет \term{быстрое преобразование Фурье} (БПФ, англ. \eng{Fast Fourier transform, FFT}), обеспечивающее
  вычисление коэффициентов спектра за меньшее число операций. В основу БПФ положен принцип разбиения
  заданной последовательности отчётов дискретного сигнала на несколько промежуточных
  последовательностей. Для этого число отчётов $N$ разделяется на множители. Затем, определяются
  спектры этих промежуточных последовательностей, и через них находится спектр всего сигнала.
  За счёт этого удаётся избежать большого числа повторяющихся при вычислении ДПФ операций.
  Особенно эффективно это позволяет обрабатывать сигнальные последовательности со значениями
  $N$, являющимися степенью числа $2$ за счёт возможности многократно делить входную
  последовательность отчётов на подпоследовательности.

  Впрочем, частотный анализ, эффективную реализацию которого представляет собой БПФ, является не
  единственным возможным способом анализа сигналов. Недостатками БПФ является отсутствие в
  получаемом спектре информации о том, как частоты изменяются со временем (как следствие,
  принципиально разные сигналы могут иметь одинаковый спектр), а также трудность детектирования
  импульсных помех (в спектре они оказываются растянуты по широкой частотной области и имеют низкую
  амплитуду). Для преодоления этих недостатков могут применяться различные методы: оконное
  преобразование Фурье, вейвлет-преобразование и авторегрессионные модели, обзор которых приводится
  в работе~\cite{veggeberg-signal-processing}.

  \term{Оконное преобразование Фурье} является модификацией классического преобразования Фурье, при
  котором временной интервал ограничивается за счёт умножения исследуемого сигнала на оконную
  функцию, отличную от нуля на ограниченном интервале. Результатом его применения является двумерная
  спектрограмма~--- интенсивность зависит от двух независимыми переменных: частоты и времени.
  В~отличие от классического Фурье-спектра, такая спектрограмма содержит больше информации о
  сигнале, так как отражает не только частотные, но и временн\'{ы}е зависимости.

  Другой широко используемый метод~--- \term{вейвлет-анализ}~--- также имеет много общего с
  Фурье-анализом. Отличием является то, что в качестве базисных функций используются не синусы и
  косинусы, а специальные функции, ограниченные как во временной, так и в частотной области~---
  \term{вейвлеты}. Множество базисных функций при этом получается из исходной функции (порождающего
  вейвлета) за счёт операций сдвига и масштабирования. Такие функции лучше подходят для представления
  реальных сигналов которые, в отличие от тригонометрических функций, ограничены во времени и могут иметь
  резкие перепады. Как и в случае оконного преобразования Фурье, результатом вейвлет-преобразования является
  двумерная спектрограмма, только в этом случае независимыми параметрами являются величины сдвига и
  масштабирования. На практике это позволяет эффективно обнаруживать импульсные помехи, которые
  будут приводить к увеличению определённых вейвлет-коэффициентов по сравнению с сигналом без помех.

  Принципиально другой подход связан с использованием \term{авторегрессионных моделей} (англ.
  \eng{AR-model}). В таких моделях дискретный сигнал представляется в виде суммы детерминированной и
  стохастической части: линейной комбинации предшествующих отсчётов и случайной ошибки.
  Коэффициенты линейной комбинации при этом представляют оценку спектра сигнала, а резкие увеличения
  коэффициента случайной ошибки свидетельствуют о наличии импульсных помех в исходном сигнале.

  Выше были перечислены популярные методы цифровой обработки сигналов. Выбор конкретного алгоритма
  анализа определяется особенностями решаемой задачи и является ключевым моментом, определяющим
  достижение поставленной цели \cite{zubarev-realtime}.

  \subsection{Устройство синхронизации процесса измерения}\label{ssec:sync}

  Точная синхронизация процедур обработки
  сигналов возможна за счёт применения вычислительных процессоров и специализированных
  инструментальных средств. Решение этой задачи позволяет синхронизировать отдельные процессы
  обработки информации, что является существенным фактором возможности применения
  цифровой обработки сигналов в специализированных областях радиофизики и геофизики \cite{rathore-digital}.
  Синхронизация имеет такое большое значение, поскольку степень её точности напрямую влияет на
  достоверность измерения сигнала. Помимо того, что неверная привязка отсчётов отдельно взятого
  оцифрованного сигнала ко времени приводит к искажению его формы, также важна синхронизация между
  различными одновременно измеряемыми сигналами, то есть между каналами измерения в многоканальных
  системах. Например, в сейсмологии анализируется разность времени прихода сейсмической волны к
  распределённым в пространстве датчикам, которую можно точно определить только в том случае, если
  все каналы измерения синхронизированы между собой. % TODO ссылка ?

  Синхронизация может производиться двумя основными способами: с помощью сигналов синхронизации,
  передаваемых от устройства синхронизации, либо с использованием общего источника точного времени,
  в~качестве которого могут выступать протоколы точного времени (NTP или PTP) или глобальная система
  позиционирования (GPS).

  Традиционный подход к синхронизации заключается в проведении линий синхронизации от генератора
  синхроимпульсов ко всем синхронизируемым устройствам. Синхронизация на основе таких сигналов
  синхронизации является довольно гибкой и обеспечивает высокую точность, но имеет существенное
  ограничение по длине линий синхронизации. Слишком большая длина линий приводит к разности времени
  хода сигналов синхронизации и потере точности, и в этом случае более предпочтительным является
  использование источников точного времени, в частности, GPS.

  % TODO добавить картинку, показывающую сравнение двух подходов

  Использование системы GPS
  позволяет добиться точности межканальной синхронизации не менее 100 нс \cite{lombardi-gps}, причём в случае
  распределённого в пространстве объекта измерения нет необходимости направлять синхроимпульсы из
  единого устройства синхронизации, а можно использовать с каждым территориальным измерительным
  каналом свой GPS-приёмник, причём точность синхронизации при этом не изменяется,
  одновременно отсутствует погрешность обусловленная прохождением синхроимпульсов по длинным
  распределённым линиям. Дополнительным преимуществом является то, что при такой синхронизации
  данные привязаны к глобальному стандартному времени, что позволяет ассоциировать данные измерений
  из экспериментов, проведённых различными исследователями \cite{veggeberg-sync}.

  % ------ end section ------------

  \paragraph{Выводы к разделу.}
  Таким образом, в данном разделе были рассмотрены аппаратные компоненты и структура измерительных
  информационных систем, приведён оптимальный способ построения канала измерения, сделан
  краткий обзор алгоритмов цифровой обработки сигналов. Отдельно
  рассмотрены особенности применения микропроцессоров и устройств синхронизации в ИИС,
  показаны преимущества использования системы GPS для реализации процесса синхронизации.

  В следующем разделе рассмотрены программные компоненты ИИС: задачи стоящие перед ними, существующие
  программные решения для этих задач и предлагаемые в рамках данной работы методы и подходы к их решению.

  \section{Программные компоненты ИИС}\label{sec:software}

  Программное обеспечение измерительных информационных систем является основным предметом данной
  работы. В этом разделе приводится обзор программных компонентов измерительных систем.
  Рассмотрены существующие программные решения, обоснована необходимость разработки собственного
  универсального программного обеспечения для обработки экспериментальных данных и описаны
  предлагаемые архитектурные решения и методы.

  Далее приведены базовые принципы разработки программного обеспечения, которые применимы и к ПО
  измерительных систем, а затем рассмотрены характерные именно для ИИС задачи и требования к
  программным компонентам.

  % ------ begin section ------------

  \subsection{Общие принципы разработки ПО}\label{ssec:software-principles}

  % Какие общие принципы стоит описать?
  % - организация в виде исполняемых файлов / библиотек
  % ✔ принципы модульности, переиспользования
  % ✔ что-то ещё из серии ООАД (?)
  % - как правильно оптимизировать приложения
  % - принципы параллельного программирования

  Принципы разработки любого программного обеспечения определяются тем, что конечная цель
  процесса разработки~--- в заданные сроки создать
  программу, выполняющую свою задачу корректно, являясь при этом надёжной и понятной для
  пользователя. Кроме того, поскольку процесс разработки крупных программных систем сложен, длителен и
  требует совместной работы большого числа людей, некоторые принципы вводятся для того, чтобы
  сделать процесс написания и поддержки программного кода более простым, детерминированным и
  снизить количество неизбежно возникающих при этом ошибок.

  Наиболее общие принципов разработки программного обеспечения перечислены ниже \cite{kernighan-practice}.
  \begin{enumerate}
    \item \term{Простота и ясность.} Для решения необходимо выбирать наиболее простой способ и простые
      структуры данных из подходящих для данной задачи. Код, реализующий их также должен быть
      простым и понятным. Не нужно ничего заранее усложнять, пока на то не возникнут объективные
      причины (недостаточная производительность, острая необходимость в расширении функциональности, и т.~п.).
      Следование этому принципу позволяет поддерживать компоненты программного кода короткими и
      управляемыми, облегчает понимание кода как людям, так и машинам.
    \item \term{Универсальность.} Нужно стремиться решать каждую проблему один раз в наиболее общем виде,
      а не повторять её решение для каждого из специфических случаев. Это позволяет избежать
      нежелательного дублирования кода (которое затрудняет поддержку и может привести к
      ошибкам), а также способствует переносимости решений, то есть возможности их функционирования в широком
      диапазоне ситуаций и адаптации к новым условиям.
    \item \term{Модульность.} Программный код нужно организовывать в виде компонентов
      (модулей), имеющих чётко определённую задачу и набор функций. Это открывает возможности для
      переиспользования программного кода, что также связано с принципом универсальности.
      Уменьшение связей между модулями (в том числе за счёт проработанного интерфейса и сокрытия
      деталей реализации) упрощает их независимую разработку и развитие, что важно при совместной
      работе над системой нескольких программистов.
    \item \term{Интерфейсы} как отдельных компонентов, так и всей программной
      системы должны быть последовательными, чтобы их можно было без труда понять и использовать,
      полными, но не избыточными. Здесь под интерфейсами понимаются как пользовательские (между
      программой и пользователем), так и программные интерфейсы (между программами или компонентами программы).
      Упомянутые выше принципы простоты и универсальности также относятся и к интерфейсам.
    \item \term{Эволюция.} Как правило, не удаётся создать полностью пригодную программную систему с
      первой попытки. Важно грамотно организовать этот итеративный процесс, учитывать обратную
      связь от пользователей, что позволяет достичь цели за меньшее число итераций.
      Немаловажным для такой организации является использование системы контроля версий (англ. \eng{Version
      Contorl System, VCS}) и системы отслеживания ошибок (англ. \eng{Bug Tracking System}).
    \item \term{Автоматизация.} Часто повторяющиеся рутинные задачи нужно автоматизировать с
      использованием средств генерации кода, автоматических средств профилирования и тестирования.
      Выполнение таких задач вручную является не только бессмысленной тратой времени и усилий, но и вероятной
      причиной ошибок.
  \end{enumerate}

  % TODO добавить про то, что не надо изобретать велосипед, а по возможности пользоваться готовыми либами

  Все перечисленные выше принципы в большинстве случаев относятся и к ПО измерительных информационных
  систем, но у программных компонентов ИИС есть и свои особенности, которые описаны далее.

  % Про какие компоненты можно рассказать?
  % - коммуникации
  % - обработка
  % - принятие решений
  % - сохранение
  % - GUI

  \subsection{Задачи и требования к программным компонентам ИИС}

  Набор программных компонентов и задачи, решаемые ими, в каждой измерительной информационной
  системе определяется набором выполняемых ею функций.
  Основные функции ИИС (рис.~\ref{fig:iis-functions}) были рассмотрены выше, в подразделе~\ref{ssec:iis-goals}.
  Исходя из принципа модульности, естественным будет такое построение, когда каждую из основных функций выполняет
  отдельный программный компонент. Поэтому в общем случае можно выделить в ИИС программные
  компоненты приёма и передачи данных и управляющих команд, обработки и сохранения данных, а также
  пользовательский интерфейс, отвечающий за ввод команд и предоставление обработанных данных в
  понятном для пользователя виде (например, в виде графиков).

  Аналогичным образом основные требования к программным компонентом ИИС напрямую вытекают из
  требований к самим ИИС, рассмотренных в подразделе~\ref{ssec:iis-requirements}. Строгая их
  формулировка приводится в монографии~\cite{slaev-soft-cert}. В этой работе рассмотрены принципы,
  применяющиеся при аттестации программного обеспечения, применяемого
  в метрологии, и на основе их анализа приведены требования к такому ПО. Наиболее важные из них
  перечислены ниже.

  \begin{enumerate}
    \item Корректность алгоритмов и функций: выходные данные должны вычисляться и отображаться
      правильно. Это должно происходить даже в случае некорректных входных данных, то есть действия
      пользователя и команды, получаемые через интерфейсы связи, должны проверяться.
    \item Защита как от случайных (например, запрос перед удалением данных), так и от преднамеренных
      изменений данных.
    \item Стабильность и возможность обнаружения и обработки ошибок.
    \item Информация должна сохраняться своевременно и в полной мере.
    \item Быстродействие: задержки передачи не должны приводить к утере данных.
    \item При выводе (на экран, в файл или распечатку) основная измерительная информация не должна
      смешиваться с выводом других программных компонентов.
  \end{enumerate}

  К этим общим требованиям могут добавляться требования, определяемые конкретной задачей, например,
  использование определённого протокола передачи данных. Кроме того, сами общие требования, как
  правило, конкретизируются. Так, требования быстродействия формулируются в виде конкретных цифр:
  максимальное время отклика, предельный срок завершения, разброс значений времени отклика.
  Полный список требований, предъявляемый к описываемой в данной работе системе приводится в
  подразделе~\ref{ssec:requirements}.

  \subsection{Существующие программные решения}\label{ssec:existing}

  Один из подходов к реализации ПО для ИИС заключается в том, что программная часть реализуется отдельно под
  каждую конкретную задачу, как, например, в работе \cite{bak-autometry}.
  Тем не менее, существуют различные универсальные программные решения, которые можно разбить на две
  основных группы:
  \begin{enumerate}
    \item \term{SCADA-системы} (англ. \eng{Supervisory Control And Data Acquisition}~--- диспетчерское управление и
      сбор данных), программные пакеты, предназначенные для разработки или обеспечения работы в
      реальном времени систем сбора, обработки, отображения и архивирования информации об объекте
      мониторинга или управления \cite{boyer-scada}.
      Примеры таких систем: InTouch, TraceMode и др.
    \item Платформы графического программирования, такие как LabVIEW \cite{lavrov-labview}, MatLab/Simulink и др.
      Запись программ не в виде последовательных инструкций, а путём задания потоков
      данных позволяет более наглядно описать параллельно происходящие процедуры обработки.
      По отношению к программам, разработанным в LabVIEW, применяют также термин \term{<<виртуальные приборы>>}~\cite[с.~209]{rannev-iis},
      так как кроме блок-схемы процесса обработки в них можно описать графический интерфейс,
      идентичный реальному интерфейсу прибора (кнопки, регуляторы и т.\,п.).
  \end{enumerate}

  Главными преимуществами SCADA-систем являются их высокая производительность и надёжность,
  определяемые областью применения этих систем для контроля за крупными промышленными объектами.
  Это обуславливает и их главные недостатки: высокую стоимость и сложность развёртывания, а~также, в отдельных
  случаях, необходимость использования специального оборудования.

  Платформы второй группы лишены этого недостатка. Однако в отличие от SCADA-систем, они не
  представляют из себя готовые решения, будучи лишь мощными средами для разработки таковых.
  Это означает, что такие системы в полном смысле не являются аналогами предлагаемой в данной работе системы.
  И хотя наличие специализированных инструментов и готовых блоков делает создание <<виртуальных приборов>> существенно
  проще, чем разработку программ на языках программирования общего назначения, ограниченность набора этих блоков
  может являться существенным недостатком: например, это не позволит реализовать синхронизацию с
  использованием GPS, описанную в подразделе~\ref{ssec:sync}.
  Кроме того, сам подход графического программирования имеет не только преимущества, но и
  недостатки. С одной стороны, он делает процесс разработки быстрым, а получаемые при этом
  блок-схемы являются наглядными, но, с другой стороны, при этом разработчик не имеет полного контроля над
  производительностью и потреблением памяти. Это делает подобные платформы неприменимыми в случае
  ограниченных ресурсов и жёстких требований к быстродействию.

  % TODO ещё подумать, как сделать этот вывод весомым
  Таким образом, имеющиеся программные решения хотя и могут использоваться в качестве ПО
  измерительных информационных систем, но в определённых случаях такое их применение не является
  оптимальным.  Для научных экспериментов, не требующих контроля такого большого количества
  параметров, какое предлагают SCADA-системы, их использование не является оправданным в связи с высокой
  стоимостью и сложностью применения таких систем. Для прототипирования и обучения вместо них может
  быть успешно применены системы <<виртуальных приборов>>, такие как LabVIEW, но они непригодны,
  если требуется исполнение программы во встраиваемых системах, не обладающих высоким
  быстродействием, а также если необходимо наличие возможностей расширения. Именно в таких ситуация более
  применимой будет предлагаемая в данной работе система.

  Далее описаны методы и архитектурные решения, которые предлагается использовать при разработке программных
  компонентов универсальной системы обработки экспериментальных данных.

  \subsection{Предлагаемые методы разработки}\label{ssec:methods}

  В данной работе предлагается использовать объектно-ориентированную парадигму программирования.
  Представление сущностей в виде объектов позволяет вполне воплотить описанный в подразделе~\ref{ssec:software-principles}
  принцип модульности, а инкапсуляция и наследование способствуют универсальности и чёткости интерфейсов.
  В соответствии с этим выбором архитектурные решения далее описаны в терминах \term{объектно-ориентированного
  проектирования} (англ. \eng{Object-Oriented Analysis and Design, OOAD}) \cite{booch-ooad}.

  \subsubsection{Архитектурные решения}

  \paragraph{Общая архитектура.}
  Функциональность многих программных систем чётко разделяется на три уровня: нижний~---
  манипуляции с данными (получение, обработка, сохранение), верхний~--- представление данных
  пользователю, и связывает их уровень бизнес-логики, содержащий логику поведения системы в ответ
  на те или иные события. Для систем, допускающих такое разделение, естественным является
  использование трёхзвенной архитектуры, в специальной литературе часто называемой
  \term{<<Модель~--- Представление~--- Контроллер>>} (англ. \eng{MVC: Model~--- View~--- Controller})
  \cite{gamma-patterns}. Сущности уровня данных при этом называются \term{моделями}, различные
  реализации пользовательского интерфейса~--- \term{представлениями}, а на связующем уровне логики
  находятся \term{контроллеры}.

  Различают две модификации этой архитектуры, отличающиеся ролью уровня <<Модель>>: так называемые
  <<Пассивная модель>> и <<Активная модель>>. В~первом случае (рис.~\ref{fig:mvc-passive}) модель
  представляет собой лишь источник данных и никак не может воздействовать на представления и
  контроллер, вместо этого контроллер отслеживает её изменения и он же отвечает за обновление
  представления по необходимости. Модель в этом случае является тривиальной структурой данных. Это
  может быть удобным для быстрой разработки небольшой системы, но с увеличением сложности системы
  усиливается дисбаланс между уровнями модели и контроллера: вся ответственность за обработку данных
  ложится на контроллер, из-за чего он становится крупным, сложно поддерживаемым модулем.

  \begin{myfigure}{Два варианта архитектуры MVC}{fig:mvc}
    \newcommand{\FigMvcCommonPart}{
      \tikzstyle{arrow}= [->,thick]
      \tikzstyle{curved}=[bend right]
      \tikzstyle{item} = [text centered, font=\small]
      \tikzstyle{block}= [item, theme1, rectangle, rounded corners]
      \tikzstyle{user} = [item, theme2, ellipse]
      \tikzstyle{txt}= [midway, inner sep=1mm, fill=white, font=\footnotesize]

      \node[block] (view)  {Представление};
      \node[block] (ctrl)  [right=1.5cm of view] {Контроллер};
      \node (center) at ($(view)!0.5!(ctrl)$) {};
      \node[block] (model) [above=1.5cm of center] {Модель};
      \node[user]  (user)  [below=1.5cm of center] {Пользователь};

      \draw[arrow] (user) edge [curved] node[txt]{воздействует} (ctrl);
      \draw[arrow] (view) edge [curved] node[txt]{отображает}   (user);
        \draw[arrow]  (ctrl)  edge [curved] node[txt]{изменяет}  (model);
    }
    \subfloat[С пассивной моделью]{\label{fig:mvc-passive}
      \begin{tikzpicture}[scale=1.0, transform shape]
        \FigMvcCommonPart
        \draw[arrow]        (ctrl) edge node[txt, rotate=90]{обновляет}     (view) ;
      \end{tikzpicture}
    }
    \hspace{0.05\textwidth}
    \subfloat[С активной моделью]{\label{fig:mvc-active}
      \begin{tikzpicture}[scale=1.0, transform shape]
        \FigMvcCommonPart
        \draw[arrow]  (model) edge [curved] node[txt]{обновляет} (view) ;
      \end{tikzpicture}
    }
  \end{myfigure}

  Для сложных систем более предпочтительной является схема MVC с активной моделью (рис.~\ref{fig:mvc-active}).
  Модель в такой схеме сама оповещает представления о том, что в ней произошли изменения, а
  заинтересованные представления подписываются на эти сообщения. Соответственно, значительная часть
  логики обработки данных перемещается из контроллера в модель, исключая описанный выше дисбаланс.

  Основное преимущество использования архитектуры MVC заключается в следующем.
  Отделение модели и представления от логики приложения (контроллера) позволяет иметь различные
  взаимозаменяемые реализации как модели, так и представления: в~случае модели это могут быть, например, разные протоколы
  обмена данными или разные реализации базы данных; в~случае представления~--- различные виды
  интерфейса: графический, текстовый, веб-интерфейс и~т.\,п.
  Кроме того, упрощается реализация параллельных вычислений: каждый из трёх уровней может работать
  в~отдельном потоке исполнения.

  \paragraph{Применяемые шаблоны проектирования.}
  Продуманный подход к проектированию системы, и в частности, в случае объектно"=ориентированного
  программирования, к набору классов и их интерфейсам может сделать разрабатываемую систему гибкой и
  упростить как сам процесс разработки, так и дальнейшее развитие и поддержку системы. Достичь этого
  можно, в частности, грамотным применением \term{шаблонов проектирования} (англ. \eng{Design
  Patterns})~--- переиспользуемых решений для типичных задач проектирования, возникающих в схожем
  виде при проектировании различных систем \cite{gamma-patterns}. Например, когда должен
  существовать ровно один экземпляр некоторого объекта, доступный всем клиентам, применяется шаблон
  проектирования \term{одиночка} (англ. \eng{Singleton}). При этом сам класс-одиночка инкапсулирует
  свой единственный экземпляр, запрещая создание новых извне и предоставляя доступ к нему через
  статический метод. Это может быть удобным для реализации процесса журналирования (логгирования):
  повсюду должен использоваться один и тот же объект класса \eng{Logger}, содержащий методы для
  создания диагностических сообщений.

  Продемонстрируем использование более сложного шаблона проектирования на примере поддержки
  возможности добавления новых протоколов передачи данных в систему.
  В соответствии с принципами модульности и инкапсуляции, вполне естественным является выделение всех
  операций определённого протокола в отдельный класс. Однако даже в этом случае требуемая гибкость
  не достигается: код, использующий этот класс (в частности, класс-контроллер), явно зависит от
  этого класса. При необходимости перейти на другой протокол потребуется не только создать новый
  класс, описывающий этот протокол, но и изменить код контроллера, хотя его логика никак не
  поменялась. Чтобы избежать этого, в иерархии классов все протоколы должны иметь в качестве общего
  предка абстрактный класс (интерфейс), от которого и будет зависеть контроллер. При этом уже не
  требуется модификация кода контроллера для смены протокола: контроллер можно настраивать на
  использование того или иного протокола, передавая конкретный объект, реализующий этот интерфейс.
  Но контроллер не сможет самостоятельно создать в нужный момент объект-протокол, так как ему
  известен только интерфейс и неизвестны классы его конкретных реализаций.
  Окончательное решение данной задачи содержит шаблон проектирования \term{абстрактная фабрика}
  (англ. \eng{Abstract Factory}). UML-диаграмма классов представлена на рис.~\ref{fig:abstract-factory}.

  \begin{myfigure}{Абстрактная фабрика протоколов}{fig:abstract-factory}
    \begin{tikzpicture}[scale=0.8, transform shape]
      \tikzumlset{font=\footnotesize}
      \begin{umlpackage}[fill=black!10]{Core}
        \umlclass[type=interface]{ProtocolFactory}{}{
          \umlvirt{+ createProtocol() : Protocol}
        }
        \umlclass[right=2.5cm of ProtocolFactory.south east, anchor=south west, type=interface]{Protocol}{}{
          \umlvirt{+ open()}\\
          \umlvirt{+ checkADC()}\\
          \ldots
        }
        \umlsimpleclass[left=1cm of ProtocolFactory]{Controller}
      \end{umlpackage}
      \begin{umlpackage}{Plugin}
        \umlemptyclass[below=2cm of ProtocolFactory]{SerialFactory}
        \umlemptyclass[below=2cm of Protocol]{SerialProtocol}
      \end{umlpackage}
      \umlimpl{SerialFactory}{ProtocolFactory}
      \umlimpl{SerialProtocol}{Protocol}
      \umldep[stereo=instantiate]{SerialFactory}{SerialProtocol}
      \umlassoc{Controller}{ProtocolFactory}
      \umldep[geometry=|-, anchor2=north west, stereo=use]{Controller}{Protocol}
    \end{tikzpicture}
  \end{myfigure}

  Вводится ещё один интерфейс~--- фабрика протоколов, который реализуется классом конкретной
  фабрики, своим для каждой реализации протокола. Получая одну из реализаций фабрики, контроллер
  использует её метод для создания соответствующего объекта протокола. При этом контроллер
  по-прежнему не зависит от конкретных реализаций, а только от интерфейсов.
  Возможность расширения реализуется следующим образом: конкретные реализации протокола (и
  соответствующей фабрики) находятся в подключаемых модулях (англ. \eng{plug-in}), реализованных в
  виде динамических библиотек. При запуске программа подключает все динамические библиотеки,
  расположенные в заранее определённых директориях, получая доступ к определённым в них протоколам.

  Шаблон абстрактная фабрика особенно полезен, когда каждая реализация фабрики создаёт не один, а
  несколько связанных между собой видов объектов. Например, при реализации параллельных вычислений
  может потребоваться независимость от конкретных примитивов синхронизации (семафоров, сигналов и
  т.~п.). Может существовать несколько наборов таких примитивов: свой у каждой операционной системы
  или библиотеки параллельных вычислений. Использование абстрактной фабрики позволяет иметь
  отдельные реализации фабрики для каждого из таких наборов, а интерфейс абстрактной фабрики
  содержит по методу для каждого типа объектов (один создаёт семафор, другой~--- сигнал и т.\,д.).
  Подобный подход ранее применялся автором данной работы в работе~\cite{nia-mnsk-11}.

  \subsubsection{Алгоритмические решения}
  % ✔ про сигналы-слоты: как естественно здесь применять событийно-ориентированный подход
  % ✔ что не стоит использовать исключения
  \paragraph{Обмен сообщениями.}
  Особенностью системы обработки экспериментальных является то, что все выполняемые её программными
  компонентами действия происходят как реакция на внешние события (установление связи со
  спутниками GPS, получение новых данных, и т.\,п.). Существуют различные способы реализации
  событийно"=ориентированного программирования. Например, можно для каждого события задавать
  обработчик. Обычно это либо \term{функция обратного вызова} (англ.~\eng{callback}), либо объект,
  реализующий интерфейс, метод которого является обработчиком. Возможно также применение шаблона
  проектирования \term{наблюдатель} (англ.~\eng{Observer}) \cite{gamma-patterns}, если требуется
  максимальная независимость взаимодействующих объектов друг от друга.

  В данной работе предлагается использовать простой, но гибкий подход в котором взаимодействие между
  объектами осуществляется за счёт обмена сообщениями. В этом случае необходима реализация очереди
  сообщений; в основной программе явно выделяется основной цикл, в котором происходит выборка
  сообщения из очереди и передача его на обработку (рис.~\ref{fig:message-loop}); объекты вместо
  того, чтобы вызывать методы друг друга, посылают сообщения, передавая аргументы внутри сообщения.
  Благодаря этому код обработки событий может быть более наглядным, чем в случае использования
  функций обратного вызова, а главное, такой подход позволяет реализовать взаимодействие между
  процессами, происходящими параллельно в разных потоках исполнения, без использования разделяемых
  данных и блокировок. Потокобезопасной (англ. \eng{thread-safe}) в этом случае должна быть только
  очередь сообщений.

  \begin{myfigure}{Примерный вид основного цикла}{fig:message-loop}
    \begin{lstlisting}
      // Создать очередь и добавить в неё сообщения
      MessageQueue queue;
      // \ldots
      while ( ! queue.isEmpty() ) {
        // Получить очередное сообщение
        Message * m = queue.takeMessage();
        // Передать его на обработку
        m->recipient->processMessage(m);
        delete m;
      }
    \end{lstlisting}
  \end{myfigure}
  % FIXME узнать, как правильно оформлять код

  При этом необходимо соблюдение следующего условия: обработка каждого сообщения должна происходить
  достаточно быстро, чтобы не задерживать обработку
  последующих. Впрочем, если каждый уровень модели MVC работает в своём потоке исполнения, как
  предлагалось выше, и в каждом потоке имеется свой основной цикл, то по крайней мере будет
  исключено влияние одного уровня на другой. То есть даже если в потоке графического интерфейса
  обработчик какого-либо события занимает длительное время (например, построение большого графика),
  это вызовет задержку только в обновлении графического интерфейса, но не в получении новых данных.
  Реализация очереди сообщений не является частью данной работы, поскольку, как показано далее
  в п.~\ref{sssec:techno}, используется готовое решение для организации обмена сообщениями.

  \paragraph{Обработка ошибок.} Как уже говорилось выше, важным фактором надёжности программной
  системы является обработка исключительных ситуаций (некорректных входных данных, ошибок
  ввода-вывода и~т.\,п.). В объектно"=ориентированных языках программирования для этого может
  использоваться механизм \term{исключений} (англ. \eng{exceptions}).
  Исключения позволяют генерировать ошибки на низком уровне, а обрабатывать их на высоком без
  необходимости передачи информации о произошедшей ошибке по стеку вызовов.
  Тем не менее, главный недостаток исключений заключается в том, что необработанное исключение
  приводит к аварийному завершению всей программы. Особенно усложняется контроль за отсутствием
  необработанных исключений в случае многопоточных вычислений и асинхронного выполнения операций.
  Поскольку для системы обработки экспериментальных данных важна бесперебойная работа, в описываемой
  системе предлагается отказаться от использования исключений. Для синхронных операций можно
  использовать стандартный подход передачи кода ошибки через возвращаемое значение функции, а для
  асинхронных (с отложенным исполнением)~--- назначать два обработчика: один для случая успеха,
  другой для случая ошибки, и передавать информацию об ошибке в этот обработчик. И при синхронных, и
  при асинхронных операциях подробная информация об ошибке и о том, где она произошла, записывается в
  лог (журнал) для упрощения поиска и исправления ошибок.

  % ------ end section ------------

  % FIXME узнать, надо ли обозначать выводы к разделу
  \paragraph{Выводы к разделу.}
  Таким образом, в данном разделе были описаны программные компоненты измерительных систем,
  рассмотрены общие подходы к программированию и существующие программные решения. Было показано,
  что существующие аналоги не являются удовлетворительными, и актуальна разработка собственного
  программного обеспечения обработки экспериментальных данных, а также приведены основные
  архитектурные и алгоритмические решения.

  Следующий раздел целиком посвящён практической реализации этого программного обеспечения.

  % Перевод строки чтобы избежать нежелательного переноса (приводящего к overfull hbox)
  \section[Универсальная информационная система обработки экспериментальных данных]%
          {Универсальная информационная система\\обработки экспериментальных данных}\label{sec:my-system}

  Как уже было сказано выше в~разделе \nameref{sec:intro},
  целью работы является повышение эффективности и достоверности процессов автоматизированной
  обработки измерительных сигналов. С этой целью разрабатывается универсальная информационная
  система обработки экспериментальных данных,
  специальное программное обеспечение,
  являющееся компромиссом между двумя группами имеющихся решений, описанных выше в
  подразделе~\ref{ssec:existing}, то есть готовой к интеграции, гибкой и быстродействующей системой, но не такой
  громоздкой и сложной, как SCADA-системы.

  В данном разделе постановка задачи дополнена перечислением конкретных требований, предъявляемых к
  разрабатываемой системе, затем рассмотрена архитектура системы и особенности её практической
  реализации. В заключение приведены и проанализированы полученные результаты.

  % ------ begin section ------------

  \subsection{Требования к разрабатываемой системе}\label{ssec:requirements}

  К системе предъявляются следующие требования.

  Система должна быть готовой к использованию программой, не требующей модификации программного кода
  для применения к реальной измерительной системе. В частности, система должна реализовывать
  получение данных по протоколу RS-232\cite{sweet-serial} от микроконтроллера, выполняющего оцифровку
  данных. Должна иметься возможность для расширения, добавления поддержки других протоколов впоследствии.

  Необходимо, чтобы быстродействие системы было достаточным для обработки поступающих цифровых
  сигналов в реальном времени. В частности, система должна обрабатывать в секунду не менее
  \numprint{10000} отсчётов, представленных 32-битными числами, поступающих на вход.

  Для обеспечения точности привязки по времени система должна осуществлять синхронизацию времени с
  использованием системы GPS, что было объяснено выше, в подразделе~\ref{ssec:sync}.

  Система должна иметь два режима работы: диалоговый, в~котором пользователь может управлять
  программой с помощью графического интерфейса и наблюдать изменения обрабатываемых данных,
  визуализируемых в реальном времени, и фоновый режим, в~котором графический интерфейс отключается
  для экономии ресурсов.
  При этом в случае использования во встраиваемых системах, более удобным является управление с
  помощью внешних органов управления (кнопок, переключателей). Набор таких органов может
  сильно варьироваться в зависимости от ситуации, в которой применяется данная система, но сама
  система должна оставаться универсальной. Это означает, что, аналогично описанной выше возможности
  расширения новыми протоколами получения данных, необходимо предусмотреть возможность добавления
  реализации аппаратного интерфейса.
  % TODO описать ниже, как это будет реализоваться

  Кроме отображения получаемых данных <<на лету>>, в режиме реального времени, должна иметься
  возможность визуализации ранее сохранённых данных.

  Система должна быть кроссплатформенной, то есть по крайней мере иметь возможность сборки для
  наиболее распространённых семейств операционных систем~--- \eng{Windows} и \eng{Linux}.

  Наконец, для эффективного использования вычислительной мощности многоядерных центральных
  процессоров, получающих в наши дни всё большее распространение~\cite{steam-hardware}, нужно, чтобы
  вычисления могли выполняться параллельно.

  В следующих подразделах описаны детали реализации системы с учётом перечисленных требований, а
  также рассмотренных в разделе~\ref{sec:software} принципов разработки программного обеспечения.

  \subsection{Структура системы}\label{ssec:structure}

  Система реализуется в~виде набора программ, написанных на языке C++. Выбор языка обоснован
  компромиссом между быстродействием и преимуществами объектно-ориентированной парадигмы, которые
  были рассмотрены выше, в подразделе~\ref{ssec:methods}. Система состоит из следующих программ.

  \begin{enumerate}
    \item Основная программа, реализующая получение, обработку, сохранение и визуализацию данных
      (далее~--- основная программа).
    \item Программа статистической обработки накопленных данных, используемая для визуализации
      файлов, сохранённых основной программой (далее~--- программа обработки накопленных данных).
    \item Вспомогательная программа генерации данных для тестирования
      (далее~--- генератор данных).
  \end{enumerate}

  Схема системы и способы взаимодействия входящих в её состав программ друг с другом представлено на
  рис.~\ref{fig:programs}.

  \begin{myfigure}{Программы, входящие в состав системы}{fig:programs}
    \begin{tikzpicture}[scale=1.0, transform shape]
      \tikzstyle{arrow} = [->, thick]
      \tikzstyle{item}  = [rectangle, text centered, font=\footnotesize, text width=2.5cm, minimum height=2em]
      \tikzstyle{block} = [item, theme1, rounded corners]        % usual block
      \tikzstyle{mainbl}= [block, theme1a, font=\bfseries\small] % main  block
      \tikzstyle{other} = [item, theme0]                         % other block (gray)
      \tikzstyle{file}  = [item, theme2]

      \node[mainbl](main) {Основная программа};
      \node[file]  (file) [below=of main] {Файл};
      \node[block] (stat) [right=of main] {Программа обработки накопленных данных};
      \node[other] (COM)  [left=of main]  {COM порт};
      \node[other] (MCU)  [left=of COM]   {Реальный прибор};
      \node[block] (test) [below=of MCU]  {Генератор данных};

      \draw[arrow]  (MCU) -- (COM);
      \draw[arrow]  (test.east) -| (COM);
      \draw[arrow]  (COM) -- (main);
      \draw[arrow]  (main) -- (file);
      \draw[arrow,<->] (file) -| (stat);
    \end{tikzpicture}
  \end{myfigure}

  Основная программа и программа обработки накопленных данных являются независимыми исполняемыми
  модулями. Взаимодействие между программами происходит через поддержку общего формата файлов, в
  качестве которого используется текстовый формат.
  Основная программа в ходе работы записывает файлы в~этом формате, которые затем могут быть прочитаны
  программой обработки накопленных данных. В остальном программы независимы и могут использоваться
  отдельно друг от друга.

  Генератор данных также является отдельной программой, которая используется для тестирования
  основной программы без использования реального прибора. Она эмулирует поведение микроконтроллера,
  получающего команды от основной программы и отправляющего оцифрованные данные. Взаимодействие
  между генератором данных и основной программой происходит по COM-порту согласно тому же протоколу,
  который используется в реальном приборе. Процесс тестирования подробнее описан ниже, в подразделе~\ref{ssec:testing}.

  В последующих подразделах описана архитектура этих программ и технологии, используемые при их
  разработке с учётом решений, описанных выше, в подразделе \ref{ssec:methods}.

  % TODO поиграться с отступами до и после [sub]subsection (хотя имхо и так отлично)
  \subsection{Архитектура компонентов системы}\label{ssec:arch}

  Основная программа и программа обработки накопленных данных имеют совершенно разные сценарии
  использования, вследствие чего отличается и их архитектура. Основная программа должна
  реализовывать получение, обработку и визуализацию приходящих данных в реальном времени, при этом
  иметь упомянутые выше возможности расширения. Программа обработки накопленных данных является
  гораздо более простой программой: она лишь открывает файлы в заданном формате и рассчитывает для
  них статистику. Далее отдельно рассмотрена архитектура основной программы и программы обработки
  накопленных данных. Генератор данных является тривиальной программой, поэтому её архитектура
  отдельно не рассматривается.

  \subsubsection{Архитектура основной программы}\label{sssec:main-arch}

  Функциональность основной программы чётко разделяется на три части: получение данных, их
  преобразование и визуализация. Поэтому наиболее подходящей архитектурой становится <<Модель~---
  Представление~--- Контроллер>>, что было обосновано выше в подразделе~\ref{ssec:methods}, при этом
  получение данных соответствует уровню <<Модель>>, операции с данными~--- уровню <<Контроллер>> и,
  соответственно, визуализация~--- уровню <<Представление>>.  Поскольку в~данной программе для
  достижения реального времени требуется как можно более быстрая реакция на поступающие данные, то
  при реализации этой программы используется вариант архитектуры MVC с активной моделью,
  при котором модель сама инициирует процесс уведомления о появлении новых данных.

  Таким образом, архитектура основной программы приобретает вид, показанный на рис.~\ref{fig:main-arch}.
  Стрелками показано направление движения данных, пунктиром~--- реализация абстрактного класса.

  \begin{myfigure}{Архитектура основной программы}{fig:main-arch}
    \begin{tikzpicture}[scale=1.0, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{impl}   = [->, thick, dashed]
      \tikzstyle{label}  = [draw=none, fill=none, font=\footnotesize\em]
      % item - общий стиль-предок для разных видов блоков
      \tikzstyle{item}   = [rectangle, text centered, font=\footnotesize, minimum height=2.5em]
      % block - общий стиль-предок для округлых блоков
      \tikzstyle{block}  = [item, rounded corners, thick, text width=3cm]
      % box - общий стиль-предок для прямоугольных блоков
      \tikzstyle{box}    = [item, text width=1cm]
      % model, view, ctrl - три уровня MVC
      \tikzstyle{model}  = [theme1]
        \tikzstyle{mblk} = [model, block]
        \tikzstyle{mbox} = [model, box]
      \tikzstyle{view}   = [block, theme2]
      \tikzstyle{ctrl}   = [block, theme3]
      % блоки
      \node[mblk] (Proto) {Абстрактный\\протокол};
      \node[mbox] (COM)   [below=6mm of Proto.south west, anchor=north west] {COM\\порт};
      \node[mbox] (Eth)   [below=6mm of Proto.south east, anchor=north east] {Ethe\-rnet};
      \node[mblk] (File)  [above=6mm of Proto] {Запись\\файла};
      \node[ctrl] (Core)  [right=of Proto] {Ядро};
      \node[view] (GUI)   [right=of Core ] {Графический\\интерфейс};
      \node[view] (CLI)   [below=6mm of GUI  ] {Текстовый\\интерфейс};
      % стрелки
      \draw[arrow] (Proto.east) -- (Core);
      \draw[arrow] (Proto.east) -- ++(5mm, 0) |- (File);
      \draw[arrow] (Core.east) -- (GUI.west);
      \draw[arrow] (Core.east) -- ++(5mm, 0) |- (CLI.west);
      \draw[impl]  (COM) -- (Proto.south-|COM);
      \draw[impl]  (Eth) -- (Proto.south-|Eth);
      % подписи
      \node[label] [above=2cm of Proto] {Модель};
      \node[label] [above=2cm of Core ] {Контроллер};
      \node[label] [above=2cm of GUI  ] {Представление};
    \end{tikzpicture}
  \end{myfigure}

  С точки зрения объектно-ориентированного проектирования, каждый из блоков на рис.~\ref{fig:main-arch}
  реализуется в~виде класса, причём классы, реализующие различные протоколы (например, RS-232,
  Ethernet, виртуальный тестовый протокол для проверки и~т.\,п.), наследуются от общего абстрактного
  класса-родителя. Эти архитектурные решения были рассмотрены выше, в подразделе \ref{ssec:methods}.

  \subsubsection{Архитектура программы обработки накопленных данных}

  В~программе обработки накопленных данных, как и в основной программе, описанной выше в
  п.~\ref{sssec:main-arch}, независимость визуализации от обработки данных также делает уместным
  применение архитектуры MVC. Но в~отличие от основной программы, здесь данные не приходят извне, а
  считываются из файла и в~дальнейшем при необходимости редактируются пользователем, то~есть и их
  изменение происходит изнутри, а не извне программы. Всё это приводит к тому, что здесь можно использовать
  более простой вариант архитектуры MVC с <<пассивной>> моделью. Как уже упоминалось выше, недостатком этого варианта является
  то, что при этом значительная часть программного кода сосредоточена в контроллере, а модель и
  представление тривиальны. Впрочем, для данной программы этот недостаток не является критическим,
  так как её функциональность не настолько велика, чтобы класс-контроллер оказался перегружен.
  На рис.~\ref{fig:stat-arch} представлена архитектура программы обработки накопленных данных.

  \begin{myfigure}{Архитектура программы обработки накопленных данных}{fig:stat-arch}
    \begin{tikzpicture}[scale=0.9, transform shape]
      \tikzstyle{arrow}  = [->, thick]
      \tikzstyle{label}  = [draw=none, fill=none, font=\footnotesize\em]
      % item - общий стиль-предок для разных видов блоков
      \tikzstyle{item}   = [rectangle, text centered, font=\footnotesize, minimum height=2.5em]
      % block - общий стиль-предок для округлых блоков
      \tikzstyle{block}  = [item, rounded corners, thick, text width=3cm]
      % model, view, ctrl - три уровня MVC
      \tikzstyle{modl}   = [block, theme1]
      \tikzstyle{view}   = [block, theme2]
      \tikzstyle{ctrl}   = [block, theme3]
      % блоки
      \node[modl] (Stat)  {Статистика};
      \node[modl] (Readr) [below=0.75cm of Stat] {Чтение\\файла};
      \node[modl] (Writr) [below=0.3cm of Readr] {Запись\\файла};
      \node[ctrl] (Core)  [right=of Stat] {Ядро};
      \node[view] (GUI)   [right=of Core ] {Графический\\интерфейс};
      \node[view] (Print) [below=0.75cm of GUI ] {Печать\\отчёта};
      % стрелки
      \draw[arrow]    (Readr) -| (Core.220);
      \draw[arrow] (Core.320) |- (Writr);
      \draw[arrow]     (Core) -- (Stat);
      \draw[arrow,<->] (Core) -- (GUI);
      \draw[arrow]     (Core.east) -- (Print.north west);
      % подписи
      \node[label] [above=3mm of Stat] {Модель};
      \node[label] [above=3mm of Core] {Контроллер};
      \node[label] [above=3mm of GUI ] {Представление};
    \end{tikzpicture}
  \end{myfigure}

  Стрелками
  показано направление движения данных. Видно, что всеми потоками данных управляет контроллер, что и
  является особенностью варианта MVC с пассивной моделью.

  \subsection{Программная реализация системы}

  В данном подразделе описано, как перечисленные в подразделах \ref{ssec:methods} и \ref{ssec:arch}
  архитектурные и алгоритмические решения воплощаются на практике в программном коде системы.
  В первую очередь рассмотрены те сторонние инструменты и готовые решения, которые используются в
  качестве строительных блоков для реализации системы. Затем рассмотрены детали программной
  реализации программ, входящих в состав системы.

  \subsubsection{Используемые технологии}\label{sssec:techno}

  После того, как сделан выбор языка программирования для реализации системы (в данном случае это
  C++, как было указано в разделе \ref{ssec:structure}), необходимо определиться с набором используемых
  программных библиотек. В~случае, если подходящие библиотеки для данного языка имеются, и являются тщательно
  протестированными, то их использование более предпочтительно, чем самостоятельная реализация той
  же функциональности. Если некий набор библиотек реализует комплексный подход к~решению
  определённого круга задач, то такие библиотеки могут объединяться в общую систему, существенно
  определяющую структуру использующего их приложения. В~этом случае говорят уже не об отдельных
  библиотеках, а о~так называемом программном каркасе, или фреймворке (англ. \eng{framework}).

  Далее описан выбор базового MVC-фреймворка, а так же библиотек для реализации
  конкретных функций уровней модели и представления.

  \paragraph{Базовый MVC-фреймворк.}
  Поскольку MVC выбрана в~качестве основной архитектуры для обеих программ, то особенно важным
  становится выбор библиотеки или фреймворка, отвечающих за реализацию этой модели в программном
  коде. Как было сказано выше, выбранный фреймворк будет влиять и накладывать свои ограничения и на
  структуру разрабатываемой программы. Именно поэтому особого внимания заслуживают свободные и
  кроссплатформенные библиотеки и фреймворки: их использование не требует дополнительных затрат на
  лицензию, открытый свободный код даёт больший контроль над возможностями библиотеки \cite{open-source},
  а кроссплатформенность исключает проблемы, которые могут впоследствии возникнуть при необходимости
  переноса программы на другую платформу.

  Среди имеющегося в~настоящее время свободного кросплатформенного программного обеспечения для разработки
  графического интерфейса на языке C++ наиболее распространены библиотека GTK+ (сокращение от англ.
  \eng{GIMP ToolKit}) \cite{gtk} и фреймворк Qt (произносится <<кьют>>) \cite{qt}. В данной работе
  выбор сделан в~пользу Qt, поскольку этот фреймворк обладает следующими преимуществами.
  \begin{enumerate}
    \item Расширение языка C++, реализуемое с помощью \eng{Meta Object Compiler (MOC)}, который
      транслирует расширенный диалект C++ в стандартный C++. Это означает, что можно использовать в
      программном коде дополнительные языковые конструкции, независимо от используемого компилятора.
    \item Мощная модель так называемых <<сигналов>> и <<слотов>>, позволяющая использовать
      событийно-ориентированное программирование, причём MOC обеспечивает лаконичный синтаксис их определения.
      Именно это позволяет реализовать взаимодействие между различными объектами согласно модели
      обмена сообщениями, описанной в подразделе \ref{ssec:methods}, причём очередь сообщений уже
      реализована в ядре Qt.
    \item Широкие возможности графического интерфейса с возможностью расширения стандартного набора
      элементов пользовательскими либо элементами из сторонних библиотек. В состав интегрированной
      среды разработки Qt Creator, поставляемой вместе с Qt, входит мощный визуальный редактор
      графического интерфейса (рис.~\ref{fig:qt-creator}).
    \item Простота локализации приложения на новый язык благодаря инструменту \eng{Linguist},
      входящему в состав Qt.
  \end{enumerate}

  \includefigure[width=0.85\linewidth]{Среда разработки Qt Creator в режиме визуального редактора.
    Видно большое разнообразие графических элементов, представление логической иерархии в виде
    дерева, а также редактор меню и сигналов-слотов.}{qt-creator}

  Остановимся подробнее на концепции сигналов и слотов, поскольку из перечисленных выше преимуществ
  это является наиболее существенным. Цель этой концепции~--- организация взаимодействия,
  коммуникации между объектами, то есть возможности одним объектам устанавливать свои обработчики на
  события, генерируемые другими объектами. При этом из перечисленных в подразделе~\ref{ssec:methods}
  подходов этот ближе к обмену сообщениями, нежели к функциям обратного вызова (\eng{callback}).
  Однако и от прямого обмена сообщениями он несколько отличается, поскольку вместо явной отправки
  сообщений конкретному получателю и обработки этих сообщений взаимодействие определяется путём
  соединения \term{сигналов} и \term{слотов}. В объекте, являющемся источником события, объявляется
  сигнал, то есть функция без тела с определённой сигнатурой. В объекте, который должен осуществлять
  обработку этого сигнала, определяется функция-слот, сигнатура которой должна совпадать с
  сигнатурой сигнала (или, по крайней мере, иметь не больше аргументов, чем сигнатура сигнала).
  Затем в любом месте кода программы можно соединить сигнал и слот путём вызова функции
  \inlinecode{connect}, являющейся частью фреймворка Qt. Вызов сигнала после этого будет приводить к
  автоматическому вызову всех соединённых с ним слотов. Минимальный пример кода, описывающий этот
  процесс, показан на рис.~\ref{fig:signals-slots}.

  \begin{myfigure}{Взаимодействие объектов с помощью сигналов и слотов в Qt}{fig:signals-slots}
    \begin{lstlisting}
      #include <QObject>
      class Sender : public QObject {
        Q_OBJECT
      public:
        void generateData() {
          QString data = ...; // Создание данных
          emit dataAvailable(data);
        }
      signals:
        void dataAvailable(const QString &data);
      } sender;

      class Receiver : public QObject {
        Q_OBJECT
      public slots:
        void processData(const QString &data) {
          // Обработка данных
        }
      } receiver;
      // При инициализации:
      connect(sender,   &Sender::dataAvailable,
              receiver, &Receiver::processData);
    \end{lstlisting}
  \end{myfigure}

  Преимущества такого подхода по сравнению с функциями обратного вызова и прямой отправкой сигналов
  заключаются в следующем \cite{qt-signals-slots}. Во-первых, это делает возможным проверку типов
  (вызов функции \inlinecode{connect} приведёт к ошибке компиляции, если сигнатуры соединяемых
  сигнала и слота не соответствуют), что позволяет выявить ошибки ещё на этапе компиляции.
  Во-вторых, это исключает зависимость между источником и получателем: этим классам может быть в
  общем случае ничего неизвестно друг о друге, и подключение или отключения сигнала и слота может
  происходить без модификации кода того и другого, и значительно лаконичнее, чем в случае явной
  отправки и обработки сообщений.

  При этом данный подход, не имея недостатков двух вышеперечисленных подходов (функции обратного
  вызова и прямая отправка сообщений), позволяет использовать преимущества их обоих. Функция
  \inlinecode{connect} может принимать ещё один необязательный аргумент, указывающий тип соединения.
  В случае, если передан параметр \inlinecode{Qt::DirectConnection}, отправка сигнала
  (\inlinecode{emit dataAvailable(data)} в примере выше) приведёт к немедленному вызову соединённого
  с ним слота, как если бы использовалась функция обратного вызова.  Если же передан параметр
  \inlinecode{Qt::QueuedConnection}, то этот вызов будет добавлен в очередь сообщений, и слот будет
  вызван из основного цикла обработки сообщений, причём в случае многопоточного приложения
  функция-слот будет вызвана именно в потоке получателя, что было описано выше как основное
  преимущество использования очереди сообщений. По умолчанию же используется параметр
  \inlinecode{Qt::AutoConnection}, который указывает на то, что выбор между прямым и отложенным
  вызовом слота происходит автоматически при отправке сигнала в зависимости от того, в одном
  потоке находятся отправитель и получатель или в разных \cite{qt-connection-type}.

  Примеры применения сигналов и слотов в реальной программе показаны ниже в п.~\ref{sssec:main-impl}.

  В данной работе используется фреймворк Qt версии 5.3.

  С учётом выбора Qt в качестве базового фреймворка, необходимо выбрать совместимые с ним библиотеки
  для важных функций основной программы: получения данных по протоколу RS-232 через последовательный
  порт и визуализации полученных данных в виде графиков. Выбор этих библиотек описан далее.

  \paragraph{Библиотека для работы с последовательным портом.}
  На момент написания работы в широком доступе имелись две сторонних библиотеки для работы с
  последовательным портом средствами Qt: QtSerialPort \cite{qtserialport} и QextSerialPort \cite{qextserialport}.
  Первая, QtSerialPort, будучи изначально сторонней библиотекой, была принята разработчиками Qt и
  войдёт в его состав, что свидетельствует о качестве этой библиотеки. Однако вторая
  библиотека, QextSerialPort, имеет некоторые серьёзные преимущества перед ней: это давно и активно
  развивающийся проект, то есть он более надёжен; поддерживает широкий набор версий Qt от Qt2 до Qt5
  что исключает проблемы обратной совместимости; наконец, не имеет внешних зависимостей (в то время
  как для сборки QtSerialPort необходим Perl). Всё это определяет выбор в~пользу QextSerialPort.
  В данной работе используется библиотека QextSerialPort версии 1.2.

  \paragraph{Библиотека для построения графиков.}
  Для построения графиков в~графическом интерфейсе Qt имеются две основных альтернативы: QWT (англ.
  \eng{Qt Widgets for Technical Applications}) \cite{qwt} и QCustomPlot \cite{qcustomplot}.  Обе эти
  библиотеки беспрепятственно интегрируются с Qt-приложением и позволяют строить графики разных
  типов. При этом однозначными преимуществами QWT являются более широкий набор функций и
  возможностей конфигурации, подробная и упорядоченная документация, а также более активный процесс разработки.
  В данной работе используется библиотека QWT версии 6.1.

  \subsubsection{Реализация основной программы}\label{sssec:main-impl}

  Ниже рассмотрены отдельные особенности программной реализации основной программы,
  проиллюстрированные фрагментами программного кода и диаграммами классов.

  \paragraph{Реализация архитектуры MVC.}
  Выше было сказано, что в качестве общей архитектуры используется трёхуровневая архитектура MVC. На
  рис.~\ref{fig:main-classes} приведена диаграмма классов основной программы, на которой показано, к
  какому уровню относится каждый класс, в соответствии со схемой архитектуры (рис.~\ref{fig:main-arch}).

  \begin{myfigure}{Диаграмма классов основной программы}{fig:main-classes}
    \begin{tikzpicture}[scale=0.8, transform shape]
      \begin{umlpackage}[fill=color1bg]{Model}
        \umlemptyclass[type=interface]{Protocol}
        \umlemptyclass[left=5mm of Protocol.north west, anchor=north east]{FileWriter}
        \umlemptyclass[below=1.5cm of FileWriter.south west, anchor=north west]{Settings}
      \end{umlpackage}
      \begin{umlpackage}[fill=color3bg]{Controller}
        \umlemptyclass[right=1.5cm of Protocol.north east, anchor=north west]{Worker}
      \end{umlpackage}
      \begin{umlpackage}[fill=color0bg]{Util}
        \umlemptyclass[below=1.5cm of Worker]{Logger}
      \end{umlpackage}
      \begin{umlpackage}[fill=color2bg]{View}
        \umlemptyclass[right=1.5cm of Worker]{MainWindow}
        \umlemptyclass[below=1.5cm of MainWindow.south west, anchor=north west]{LogWindow}
        \umlemptyclass[right=7mm of MainWindow]{TimePlot}
        \umlemptyclass[below=1.5cm of TimePlot.south east, anchor=north east]{StatsBox}
      \end{umlpackage}
      % связи:
      \umldep[geometry=|-]{FileWriter}{Protocol}
      \umluniassoc[geometry=|-]{Worker}{Protocol}
      \umluniassoc{MainWindow}{Worker}
      \umlunicompo{MainWindow}{TimePlot}
      \umlunicompo[geometry=|-|]{MainWindow}{LogWindow}
      \umlunicompo[geometry=|-|]{MainWindow}{StatsBox}
      \umldep{LogWindow}{Logger}
      \umldep[geometry=-|-, arm1=-7mm, anchor1=200]{Worker}{Settings}
    \end{tikzpicture}
  \end{myfigure}

  На диаграмме представлены основные отношения между классами. При этом обмен данными между
  различными уровнями может быть целиком реализован с помощью механизма сигналов и слотов,
  описанного в п.~\ref{sssec:techno}, что показано ниже.

  Далее отдельно рассмотрены некоторые классы, реализация которых представляет особый интерес.

  \paragraph{Абстрактный протокол.}
  Выше было предложено для обеспечения гибкости и возможности замены протоколов делать реализации
  конкретных протоколов наследниками от общего абстрактного класса. Объявление этого класса
  приведено на рис.~\ref{fig:src-protocol}.

  \begin{myfigure}{Абстрактный класс Protocol}{fig:src-protocol}
    \begin{lstlisting}
      class Protocol : public QObject
      {
          Q_OBJECT
      public:
          explicit Protocol(QObject * parent = nullptr);
          virtual QString description() = 0;
          State state() const { return state_; }

          virtual bool open() = 0;
          virtual void close() = 0;
          virtual void checkADC() = 0;
          virtual void checkGPS() = 0;

          virtual void startReceiving() = 0;
          virtual void stopReceiving() = 0;

          virtual void setSamplingFrequency(int value) = 0;
          virtual void setFilterFrequency(int value) = 0;

          virtual ~Protocol() {}

      signals:
          void checkedADC(bool success);
          void checkedGPS(bool success);
          void timeAvailable(QDateTime timeGPS);
          void positionAvailable(double latitiude, double longitude, double altitude);
          void dataAvailable(QVector<TimeStamp> timestamps, QVector<DataItem> data);
          void stateChanged(State newState);
      private:
          State state_;
      };
    \end{lstlisting}
  \end{myfigure}

  Все основные действия, которые могут быть совершены над протоколом, выделяются в методы этого
  класса, при этом в самом классе \inlinecode{Protocol} они являются чисто виртуальными, то есть не
  имеют реализации. При наследовании в конкретной реализации все их нужно определить.
  Также в этом абстрактном классе задаётся набор сигналов, которые каждая конкретная реализация
  должна использовать для оповещения о происходящих событиях: успешной проверке АЦП, синхронизации
  времени с GPS, получении новых данных и~т.\,п.
  Ниже описано назначение этих методов и обобщённый сценарий использования этого класса клиентским кодом.

  Метод \inlinecode{open} открывает протокол, то есть устанавливает соединение с источником данных
  (например, реализация протокола RS-232 открывает COM-порт, к которому подключён
  микроконтроллер, передающий оцифрованные данные) и возвращает \inlinecode{true} в случае успеха.
  Далее, используя методы \inlinecode{checkADC} и \inlinecode{checkGPS} инициируется проверка
  готовности АЦП и GPS-приёмника. Поскольку этот процесс подразумевает отправку команд и ожидание
  ответа, результат проверки сообщается не в виде возвращаемого значения (иначе функция блокировала
  бы исполнение до завершения операции), а асинхронно, путём отправки соответствующих сигналов
  (\inlinecode{checkedADC} и \inlinecode{checkedGPS}, соответственно). Аналогичным образом протокол
  оповещает и о получении от GPS-приёмника точного времени и координат: путём отправки сигналов
  \inlinecode{timeAvailable} и \inlinecode{positionAvailable}, передавая полученное время и
  координаты в качестве параметров сигналов. Поэтому необходимо подготовить
  обработчики этих сигналов, то есть соединить эти сигналы с некоторыми слотами до вызова методов
  \inlinecode{checkADC} и \inlinecode{checkGPS}. Далее, до запуска приёма данных можно изменять
  параметры их получения (частоту фильтра и частоту выборки), после чего процесс приёма инициируется
  вызовом метода \inlinecode{startReceiving}, а останавливается вызовом \inlinecode{stopReceiving}.
  В промежутке между ними протокол оповещает о полученных данных с помощью сигнала
  \inlinecode{dataAvailable}, параметрами которого являются массивы отсчётов времени и данных.
  Следует отметить, что несмотря на то, что в определении этой функции аргументы передаются ей не по
  ссылке, а по значению, это не приводит к нежелательному копированию всего массива: класс
  \inlinecode{QVector} автоматически обеспечивает общее использование (англ. \eng{Implicit Sharing})
  между несколькими экземплярами, так что копируется при этом только один указатель \cite{qt-implicit-sharing}.
  После завершения работы с протоколом соединение необходимо закрыть (метод \inlinecode{close}).

  % TODO поподробнее про различные операции. Что-то сказать и про конкретные реализации (serial, test)?

  \paragraph{Запись файлов.}
  Поскольку все получаемые данные должны быть в конечном итоге записаны в файл, в простейшем случае
  запись в файл могла бы производиться прямо в коде класса, осуществляющего их получение, то есть
  протокола. Однако при наличии нескольких протоколов это уже не обеспечивает должной
  универсальности, и в разных реализациях протокола при этом будет дублирующийся код. Кроме того, в
  любом случае следует стремиться к тому, чтобы каждый класс решал одну чётко определённую задачу.
  Поэтому оправдано вынести процесс записи данных в файл в отдельный класс.
  %
  Он отвечает как за установку тех параметров, которые будут записаны в заголовок файла, так и
  собственно за получение и запись данных. Вполне естественно внести в число его функций и
  накопление в очереди данных, которые по каким-либо причинам ещё не были записаны на диск (диск
  недоступен, автозапись временно отключена пользователем, и~т.\,п.), а также форматирование имени
  файла и автоматическое открытие и закрытие файлов. Объявление этого класса приведено на
  рис.~\ref{fig:src-filewriter}.

  \begin{myfigure}{Класс, отвечающий за запись файлов}{fig:src-filewriter}
    \begin{lstlisting}[xleftmargin=7mm, xrightmargin=7mm]
      class FileWriter : public QObject
      {
          Q_OBJECT
      public:
          explicit FileWriter(QString outputDirectory, QString fileNameFormat, QObject *parent = nullptr);
          bool isAutoWriteEnabled() const;
          QString buildFileName() const;
          ~FileWriter();
      signals:
          void queueSizeChanged(unsigned newSize);
      public slots:
          void setFileName(QString outputDirectory, QString fileNameFormat);
          void receiveData(TimeStampsVector t, DataVector d);
          void setAutoWriteEnabled(bool enabled);
          void writeOnce();
          void finishFile();
          // Параметры для заголовка файла:
          void setDeviceID(int id);
          void setCoordinates(double latitude, double longitude);
          void setFrequencies(int samplingFreq, int filterFreq);
      private:
          QQueue<QString> waitingQueue;
      };
    \end{lstlisting}
  \end{myfigure}

  Все основные операции, поддерживаемые классом \inlinecode{FileWriter}, являются слотами, что
  позволяет этому классу работать в отдельном потоке, осуществляя всё взаимодействие как с
  протоколом, так и с контроллером через сигналы и очередь сообщений. При этом и сам он может с
  помощью сигнала \inlinecode{queueSizeChanged} уведомлять пользовательский интерфейс о текущем размере очереди ожидающих записи
  на диск данных, например, чтобы в случае превышения заданного предела показать пользователю предупреждение.

  Поскольку сохранение файлов является важным процессом, который при этом может варьироваться в
  зависимости от ситуации, важно, чтобы этот класс имел достаточно гибкий интерфейс. Для этого
  необходимо, чтобы никакие параметры не были жёстко зафиксированы в коде класса (англ.
  \eng{hard-coded}). В предлагаемой реализации все параметры, включая формат имени файла,
  директорию для записи файлов и информацию для заголовка, могут быть изменены динамически с помощью
  соответствующих методов-слотов. Изменение директории или имени файла автоматически приводит к корректному
  закрытию прежнего файла и открытию нового, так что при этом никакие данные не теряются.

  \paragraph{Уровень контроллера.} % про Worker
  Если на уровне модели могут использоваться разные протоколы передачи, а на уровне представления~---
  графический либо текстовый интерфейс, то уровень контроллера содержит ту логику, которая
  независимо от этих вариантов остаётся неизменной. При грамотном подходе к проектированию уровней
  модели и представления уровень контроллера является довольно тонкой и прозрачной прослойкой между
  ними. В данной программе он отвечает только за то, чтобы соблюдался описанный выше сценарий работы с
  протоколом (сначала должны быть проверены АЦП и GPS, после чего автоматически может быть запущен
  приём данных, в конце протоколы должны быть закрыты) и предоставляет подходящий программный интерфейс для уровня представления.
  Объявление класса \inlinecode{Worker}, представляющего уровень контроллера, приведено на
  рис.~\ref{fig:src-worker}.

  \begin{myfigure}{Класс-контроллер, обеспечивающий прослойку между моделью и представлением}{fig:src-worker}
    \begin{lstlisting}
      class Worker : public QObject
      {
          Q_OBJECT
      public:
          enum PrepareResult { ... };
          enum StartResult { ... };

          Worker(Protocol* protADC, Protocol* protGPS, QObject *parent = nullptr);

          bool isPrepared() { return prepared; }
          bool isStarted() { return started; }
          bool isPaused() { return paused; }

          ~Worker() { finish(); }
      public slots:
          void reset(Protocol* protADC, Protocol* protGPS);
          void prepare(bool autostart = false);
          void start();
          void pause();
          void unpause();
          void finish();
      signals:
          void prepareFinished(PrepareResult result);
          void triedToStart(StartResult result);
          void dataUpdated(TimeStampsVector newTimeStamps, DataVector newData);
      private slots:
          void onCheckedADC(bool);
          void onCheckedGPS(bool);
      };
    \end{lstlisting}
  \end{myfigure}

  Как и в случае с классом \inlinecode{FileWriter}, описанным выше, взаимодействие с классом
  \inlinecode{Worker} осуществляется асинхронно: через сигналы и слоты. В частности, результат
  выполнения метода \inlinecode{prepare} сообщается путём отправки сигнала
  \inlinecode{prepareFinished}, а результат вызова \inlinecode{start}~--- путём отправки сигнала
  \inlinecode{triedToStart}. Результат кодируется одним из значений соответствующего перечисления и
  передаётся в качестве параметра сигнала. При этом большинство операций просто делегируются уровню
  модели, то есть объекту-протоколу. Поэтому можно сказать, что основная задача этого класса~---
  предоставить упрощённый интерфейс к классу \inlinecode{Protocol}, допускающий асинхронное
  взаимодействие.

  В общем случае взаимодействие с АЦП и GPS может происходить через разные порты, поэтому конструктор
  данного класса принимает два аргумента: протокол для работы с АЦП и протокол для работы с
  GPS-приёмником. Впрочем, эти два указателя могут совпадать, если оба взаимодействия происходят по одному и
  тому же порту. Эта ситуация отслеживается и корректно обрабатывается, так что операции открытия и
  закрытия в этом случае не будут выполнены над одним протоколом дважды.

  \paragraph{Расширение графических компонентов.}
  Даже при богатом наборе стандартных компонентов графического пользовательского интерфейса может
  возникнуть необходимость в расширении этого набора специфическими для данной задачи компонентами.
  Она возникает, во-первых, когда некая комбинация компонентов переиспользуется как единое целое;
  во-вторых, если требуется добавление или незначительное изменение функциональности одного из
  существующих компонентов. Эти два случая не являются взаимоисключающими, так как порой
  требуется и то, и другое, то есть комбинацию компонентов нужно не только использовать как единое
  целое, но и добавить дополнительную функциональность.

  Первый случай более прост и может быть реализован без введения новых классов. Комбинация из
  стандартных компонентов может быть описана в виде .ui-файла (XML-файлы, создаваемые инструментом
  \eng{Qt Designer}), который затем может быть использован как на этапе компиляции, так и во время
  исполнения \cite{qt-ui-file}.

  Если же требуется добавление функциональности, особенно собственных сигналов и слотов, необходимо
  выделять собственный компонент в отдельный класс. В случае, если нужно изменить или расширить
  поведение некоторого компонента, новый класс наследуется от класса исходного компонента и
  в нём переопределяются или добавляются методы, сигналы и слоты. После этого объект нового класса
  может использоваться везде, где использовался объект исходного класса. Такой подход используется в
  данной работе для добавления к компоненту \inlinecode{QwtPlot}, представляющему двумерный график
  (часть используемой библиотеки QWT, см. п.~\ref{sssec:techno}), дополнительных функций хранения
  и настройки размера истории, а так же добавления подходящих слотов для сопряжения этого класса с
  классом \inlinecode{Protocol}, описанным выше. Объявление класса \inlinecode{TimePlot},
  реализующего такое расширение, приведено на рис.~\ref{fig:src-timeplot}.

  \begin{myfigure}{Пример расширения существующего графического компонента новыми функциями}{fig:src-timeplot}
    \begin{lstlisting}
      class TimePlot : public QwtPlot
      {
          Q_OBJECT
      public:
          explicit TimePlot(QWidget *parent = nullptr)
              : QwtPlot(parent)
          {
              QwtPlotGrid * grid = new QwtPlotGrid;
              grid->setMajorPen(QPen(GRID_COLOR));
              grid->setMinorPen(QPen(GRID_COLOR, 1, Qt::DashLine));
              grid->attach(this);
              curve = new QwtPlotCurve;
              curve->setPen(CURVE_COLOR, CURVE_WIDTH);
              curve->setOrientation(Qt::Vertical);
              curve->attach(this);
          }
      public slots:
          // Слот для получения данных от Protocol
          void receiveData(TimeStampsVector timestamps, DataVector items);
          void clearHistory();
          // Настройки
          void setPointsPerSec(int value);
          void setHistorySecs(double secs);
          void setFixedScaleY(bool fixed);
          void setFixedScaleYMax(double max);
      private:
          QwtPlotCurve * curve;
          // Буфер для хранения истории
          QVector<QPointF> buffer;
      };
    \end{lstlisting}
  \end{myfigure}

  Этот класс является примером расширения с целью добавления новых функций и нового программного
  интерфейса, а также инкапсуляции некоторых параметров (в данном случае~--- \inlinecode{grid} и
  \inlinecode{curve}). Изменения существующей функциональности за счёт переопределения методов
  здесь не происходит. Примером такого переопределения является класс \inlinecode{LogWindow},
  который расширяет функциональность стандартного текстового поля для того, чтобы его можно было
  использовать для отображения сообщений журнала. Объявление этого класса, а также класса
  \inlinecode{Logger}, который повсеместно используется в коде для добавления диагностических
  сообщений, приведено на рис.~\ref{fig:src-logwindow}.

  \begin{myfigure}{Пример расширения стандартного графического компонента с переопределением функциональности}{fig:src-logwindow}
    \begin{lstlisting}
      class Logger : public QObject
      {
          Q_OBJECT
      public:
          enum Level { Trace, Info, Warning, Error };
          // Реализация шаблона проектирования Singleton
          static Logger * instance();

          void addMessage(Level level, QString message);
          void setLevelEnabled(Level level, bool value);
      signals:
          void messageAdded(Level level, QString message);
      private:
          // Запрещает создание и копирование
          Logger();
          Q_DISABLE_COPY(Logger)
      };

      class LogWindow : public QPlainTextEdit
      {
          Q_OBJECT
      public:
          explicit LogWindow(QWidget *parent = nullptr);
          virtual ~LogWindow();
      signals:
          void closed();
      public slots:
          void addMessage(Logger::Level level, QString message);
      protected:
          void contextMenuEvent(QContextMenuEvent *e) override;
          void closeEvent(QCloseEvent *) override;
      };
    \end{lstlisting}
  \end{myfigure}

  В этом примере, как и в предыдущем, к классу добавляется новый интерфейс в виде новых сигнала и
  слота, но кроме этого переопределяются некоторые методы родительского класса \inlinecode{QPlainTextEdit}
  для изменения поведения при вызове контекстного меню и при закрытии окна.

  Класс \inlinecode{Logger}, который также приведён на рис.~\ref{fig:src-logwindow}, является
  примером гибкой реализации процесса журналирования. В клиентском коде можно настроить любой способ
  обработки сообщений журнала (вывод на экран, запись в файл и т.\,п.) путём соединения сигнала
  \inlinecode{messageAdded} с различными слотами или вообще отключить часть видов сообщений.
  В ядре при этом сообщения добавляются единообразно путём получения экземпляра класса-одиночки с
  помощью метода \inlinecode{instance} и последующего вызова \inlinecode{addMessage}.

  \paragraph{Использование сигналов и слотов.}
  Выше было неоднократно упомянуто, что использование сигналов и слотов Qt позволяет реализовать
  событийно-ориентированное программирование, а также организовать асинхронное взаимодействие между
  объектами, находящимися в разных потоках исполнения. В приведённых выше фрагментах кода есть
  примеры объявления как сигналов, так и слотов. Остаётся рассмотреть только то, как эти сигналы
  соединяются со слотами для обеспечения требуемой логики поведения. На рис.~\ref{fig:src-signals-slots}
  приведены фрагменты кода основной программы, в которых упомянутые выше сигналы соединяются с
  обрабатывающими их слотами, тем самым устанавливая взаимодействие между различными объектами.

  \begin{myfigure}{Примеры соединения сигналов и слотов}{fig:src-signals-slots}
    \begin{lstlisting}[xleftmargin=0pt, xrightmargin=0pt, basicstyle=\footnotesize]
      // Сигнал можно соединять с другим сигналом:
      connect(protocolADC, &Protocol::dataAvailable, this, &Worker::dataUpdated);
      // Управление потоками данных:
      connect(worker, &Worker::dataUpdated, fileWriter, &FileWriter::receiveData);
      for(TimePlot * plot: plots) {
          connect(worker, &Worker::dataUpdated, plot, &TimePlot::receiveData);
      }
      connect(worker, &Worker::dataUpdated, mainWindow, &MainWindow::onDataReceive);
      connect(protocolGPS, &Protocol::positionAvailable,
              fileWriter,  &FileWriter::setCoordinates);
      // Передача сообщений Logger в LogWindow:
      connect(Logger::instance(), &Logger::messageAdded,
              logWindow,          &LogWindow::addMessage);
      // Лямбда-выражение в качестве обработчика сигнала:
      connect(worker, &Worker::prepareFinished, [=](Worker::PrepareResult res){
          if(res == Worker::PrepareSuccess) {
            // (подготовиться к запуску)
          } else {
            // (обработать ошибку)
          }
      });
    \end{lstlisting}
  \end{myfigure}

  Из показанных примеров видно, как именно передаются данные от протокола контроллеру (объекту
  класса \inlinecode{Worker}) и далее от него объектам классов \inlinecode{FileWriter} и
  \inlinecode{TimePlot} для записи в файл и отображения на графике, соответственно.
  Следует отметить, что кроме стандартного соединения сигнала со слотом применяются также и другие
  варианты: соединение сигнала с сигналом (позволяет создавать цепочки сигналов) и соединение
  сигнала с лямбда-выражением (когда нет необходимости выделять обработчик в отдельный метод).

  \paragraph{Сохранение настроек}
  Основная программа предоставляет широкий набор настроек, определяющих как параметры процесса
  получения и сохранения данных, так и варианты представления в пользовательском интерфейсе. К числу
  первых относятся имена и параметры COM-портов, директория и формат имени файла для сохранения,
  частоты фильтра и выборки. За изменение поведения пользовательского интерфейса отвечают такие
  настройки, как размер истории и масштаб графиков, и различные флаги: включение и отключение
  уровней диагностических сообщений и отдельных панелей окна. Поскольку при повторных запусках
  программы основная часть параметров остаётся неизменной, пользователю нужно будет совершать меньше
  повторяющихся действий, если сохранять их значения между запусками. Для этого необходимо
  записывать их в файл перед завершением программы и считывать из него при её запуске.

  В Qt имеется стандартный класс \inlinecode{QSettings}, позволяющий сохранять настройки как в
  простых INI-файлах, так и в специфичных для системы местах (реестр в Windows, файлы .plist в
  MacOS). В описываемой программе используется формат INI, чтобы один и тот же конфигурационный
  файл можно было использовать в разных операционных системах. При этом в коде программы класс
  \inlinecode{QSettings} и его методы получения и сохранения значения по ключу не используются
  напрямую. Чтобы избежать ошибок (путаницы с ключами INI-файла, использования неверного типа
  данных) для работы с настройками используется класс \inlinecode{Settings}, в котором для каждой
  настройки имеется по два метода: для чтения и записи значения. Это позволяет положиться на
  проверку типов компилятором и избежать упомянутых выше ошибок.

  \subsubsection{Реализация программы обработки накопленных данных}
  
  Ниже рассмотрены некоторые особенности реализации программы обработки накопленных данных,
  проиллюстрированные фрагментами программного кода и диаграммами классов.

  \paragraph{Диаграмма классов} программы обработки накопленных данных приведена на рис.~\ref{fig:stat-classes}.

  \begin{myfigure}{Диаграмма классов программы}{fig:stat-classes}
    \begin{tikzpicture}[scale=0.8, transform shape]
      \begin{umlpackage}[fill=color1bg]{Model}
        \umlemptyclass{Statistic}
        \umlemptyclass[below=1.5cm of Statistic]{Reader}
        \umlemptyclass[right=1cm of Reader]{Writer}
      \end{umlpackage}
      \begin{umlpackage}[fill=color0bg]{Util}
        \umlemptyclass[right=1.5cm of Writer]{Logger}
      \end{umlpackage}
      \begin{umlpackage}[fill=color3bg]{Controller}
        \umlemptyclass[above=1.5cm of Logger]{Actions}
      \end{umlpackage}
      \begin{umlpackage}[fill=color2bg]{View}
        \umlemptyclass[right=1.5cm of Actions]{MainWindow}
        \umlemptyclass[below=1.5cm of MainWindow]{LogWindow}
        \umlemptyclass[right=7mm of MainWindow]{ReportWindow}
      \end{umlpackage}
      % связи:
      \umluniassoc{MainWindow}{Actions}
      \umluniassoc{Actions}{Statistic}
      \umluniassoc[geometry=-|-,arm1=-7mm,anchor1=west]{Actions}{Writer}
      \umluniassoc[geometry=-|-,arm1=-4cm,anchor1=west]{Actions}{Reader}
      %\umldep[geometry=-|-, arm1=-7mm, anchor1=200]{Actions}{Settings}
      \umlunicompo{MainWindow}{ReportWindow}
      \umlunicompo{MainWindow}{LogWindow}
      \umldep{LogWindow}{Logger}
    \end{tikzpicture}
  \end{myfigure}

  При этом многое из описанного выше касательно основной программы относится и к программе обработки
  накопленных данных: использование сигналов и слотов, классы \inlinecode{Logger} и
  \inlinecode{LogWindow}, подходы к расширению существующих компонентов графического интерфейса.
  Далее отдельно рассмотрены такие аспекты программной реализации данной программы как внутреннее
  представление выборки в программе, а также отображение и печать отчёта.

  \paragraph{Представление выборки}
  Выбор представления данных в программе определяется тем, как эти данные должны использоваться. В
  данном случае должна иметься возможность их представления в виде таблицы и в виде графика.

  \begin{myfigure}{Представление выборки в программе: класс Statistic}{fig:src-statistic}
    \begin{lstlisting}
      class Statistic : public QObject
      {
          Q_OBJECT
      public:
          explicit Statistic(QObject *parent, QList<double> data, QString header = "", bool modified = false);
          void append(QList<double> newData);
          void remove(QModelIndexList rows);
          // Варианты представления данных
          QStandardItemModel * itemModel();
          QList<double> rawData() const;
          QVector<QwtIntervalSample> histogramSamples() const;
          QVector<QPointF> dataPoints() const;
          QString dataAsHtmlTable(int columns) const;
          // Статистические величины:
          int number() const;
          double min() const;
          double max() const;
          double average() const;
          double dispersion() const;
          double stdDeviation() const;
          double thirdMoment() const;
          double fourthMoment() const;
      signals:
          void statisticChanged();
          void histogramChanged();
          void modified();
      public slots:
          void onItemChanged(QStandardItem * item);
          void onValueChanged(int index, double newValue);
          void onHistogramIntervalsChanged(int newValue);
          void onHistogramFractionChanged(int newValue);
      };
    \end{lstlisting}
  \end{myfigure}

  \paragraph{Создание и печать отчёта}

  \subsection{Профилирование и оптимизация}

  \todo{написать раздел}

  \includefigure[width=0.85\linewidth]{Профилирование программы с помощью Valgrind в Qt Creator}{valgrind}

  \subsection{Тестирование и испытание системы}\label{ssec:testing}

  Для тестирования системы была разработана вспомогательная тестовая программа~--- генератор данных,
  во время тестирования заменяющий собой реальный измерительный прибор. В эту программу загружаются данные из
  файла, а она передаёт их по последовательному порту, преобразуя к~тому виду, который они имели бы,
  если бы приходили с~реального прибора после оцифровки микроконтроллером. Также вместо загрузки из
  файла возможна генерация случайных данных заданного вида.

  Генератор данных разрабатывался с~использованием тех же средств, что и основная программа:
  фреймворка Qt и библиотеки QextSerialPort, которые были описаны в п.~\ref{sssec:techno}.
  Внешний вид этой программы показан на рис.~\ref{fig:conserial}.

  \includefigure[width=0.4\textwidth]{Тестовая программа~--- генератор данных}{conserial}

  Процесс отладки во время разработки происходит следующим образом. На персональный компьютер,
  используемом при разработке, устанавливается эмулятор COM-порта, создающий два виртуальных порта
  ведущих себя так, как если бы они были соединены друг с другом кабелем. При помощи генератора
  данных данные передаются основной программе через этот виртуальный порт. Тем самым проверяется
  корректность реализации взаимодействия с последовательным портом и логики приложения, хотя и
  генератор данных, и основная программа физически находятся на одном компьютере.

  Для проверки работы через реальное соединение два персональных компьютера
  соединяются нуль-модемным кабелем \cite{null-modem}, на одном из них запускается основная
  программа, на другом~--- генератор данных. После установления соединения в~генератор данных
  загружаются данные из файла, и он отправляет их через это соединение на другой компьютер, где их
  получает и отображает основная программа.

  Наконец, для окончательного тестирования вместо генератора данных используется реальный прибор, в
  составе которого находится микроконтроллер, оцифровывающий сигнал, приходящий с датчиков и
  передающий его через COM-порт, а также GPS-приёмник, использующийся для синхронизации.

  \todo{подробнее описать тестирование на реальном приборе и сам прибор}

  Проведённое тестирование подтвердило корректность работы основной программы.

  \subsection{Результаты}

  Основная программа разработана и протестирована на реальных сигналах. Внешний вид программы
  представлен на рис.~\ref{fig:main}.
  \includefigure[width=0.85\textwidth]{Основная программа}{main}
  % TODO ещё скриншот в Windows?

  Принцип работы пользователя с данной программой следующий. Для её работы необходимо подключить
  микроконтроллер, выполняющий оцифровку данных, при помощи последовательного порта к персональному
  компьютеру, на котором запускается основная программа. После запуска программы указывается порт,
  по которому выполнено подключение, после чего нажатием кнопки <<Подключить>> инициализируется
  процесс соединения с микроконтроллером и обмена командами. При успешном его завершении программа
  переходит в режим готовности к приёму данных, и становится доступной кнопка <<Запуск>>. При её нажатии
  программа отправляет микроконтроллеру команду, разрешающую передачу данных и начинает
  регистрировать получаемые данные. Зарегистрированные данные отображаются в~табличном и
  в~графическом виде: в~виде графика зависимости уровня сигнала от времени. По мере работы также
  отображается время начала приёма, прошедшее время и количество полученных данных. Приём данных
  прекращается кнопкой <<Стоп>>, также имеется возможность закрыть соединение с микроконтроллером
  нажатием кнопки <<Отключить>>, после чего программа переходит в изначальное состояние и работу с
  ней можно начинать с начала.

  \todo{измерение быстродействия}

  Программа обработки накопленных данных разработана, также протестирована на данных реального
  % TODO сказать, что можно и больше, только придётся подождать
  сигнала. Было выяснено, что программа может открывать файлы объёмом вплоть до \num{100000} записей
  и рассчитывать для них статистику без серьёзного замедления в работе. Внешний вид программы
  показан на рис.~\ref{fig:stat}.
  \includefigure[width=0.6\textwidth]{Программа обработки накопленных данных}{stat}
  % FIXME можно более подробно
  % TODO более свежий скриншот? Дата файла выдаёт то, что он годовалой давности :)

  Помимо использования вместе с основной программой, данная программа может найти применение при
  исследовании физических процессов, связанных с измерением физических параметров и эффективно
  проводить качественный и количественный анализ экспериментальных данных с оперативным изменением
  процесса измерения. В программе реализованы следующие функции: ввод экспериментальных данных с
  клавиатуры и из файла, редактирование введённых данных, расчёт среднего значения,
  среднеквадратичного отклонения, дисперсии и моментов, построение настраиваемой гистограммы и кривой
  данных, генерация отчёта с возможностью сохранения его в файл в формате HTML, а также сохранения
  графиков в виде изображения PNG. При открытии или создании нового файла программа рассчитывает все
  перечисленные величины, строит кривую данных и гистограмму. В дальнейшем, при каждом
  изменении данных пользователем эти величины пересчитываются, графики обновляются. Таким образом,
  имеется возможность вводить и обновлять данные об эксперименте и уже по мере ввода видеть
  изменение статистических значений, а по завершении ввода получить готовый ответ о среднем значении
  и его точности в виде $x \pm \Delta x$.

  По итогам данной работы было опубликовано 5 работ: 1 статья \cite{nia-bogatov-13}, 2 тезиса
  докладов на конференции \cite{nia-sno-13, nia-tumaev-13} и 2 свидетельства о регистрации программы
  для ЭВМ \cite{nia-processdata, nia-seismoreg}.

  % TODO документ о внедрении?
  % TODO выводы к разделу

  \subsection{Дальнейшая работа}
  \todo{написать раздел.}

  \sectiontoc{Заключение}

  В данной работе ставилась цель разработать универсальную программную систему обработки экспериментальных данных,
  работающую в реальном времени и обеспечивающую помимо обработки точную синхронизацию по времени и
  визуализацию обрабатываемых данных. Эта цель была достигнута, и были удовлетворены поставленные в
  подразделе~\ref{ssec:requirements} требования, включая высокое быстродействие и гибкость, а~также применение
  параллельных вычислений.

  Проведено тестирование как с использованием вместо реального измерительного прибора вспомогательной
  программы, передающей через последовательный порт тестовые данные, так и на настоящем приборе в
  реальном времени. Тестирование показало пригодность системы для автоматизации процесса измерения.
  % TODO упомянуть о том, где может применяться основная программа

  Была также разработана программа для статистической обработки накопленных
  данных, которая может быть использоваться и как часть системы, и отдельно от неё, например, при
  проведении лабораторных работ по физике.

  Также были исследованы возможности дальнейшего развития и улучшения системы. В частности,
  планируется расширение набора поддерживаемых протоколов для получения данных и добавление новых
  операций обработки данных, а также ещё более глубокое применение параллельных вычислений.

  Разработанные программы зарегистрированы в реестре программ для ЭВМ. Работа была представлены на
  заседании Студенческого научного общества физико-технического факультета КубГУ и награждена
  дипломом третьей степени, а также на X Всероссийской научной конференции молодых ученых и
  студентов <<Современное состояние и приоритеты развития фундаментальных наук в регионах>>.

  \lastPageHere

  \begin{flushleft}
    \bibliographystyle{../../biblio/ugost2003} % Или использовать ugost2008 для нового ГОСТа
    \bibliography{../../biblio/my,../../biblio/own}
  \end{flushleft}
\end{document}
